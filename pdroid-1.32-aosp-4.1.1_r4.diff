diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/build/core/dex_preopt.mk b/build/core/dex_preopt.mk
--- a/build/core/dex_preopt.mk	2012-08-10 03:24:16.004912681 +0000
+++ b/build/core/dex_preopt.mk	2012-08-10 03:38:12.464933458 +0000
@@ -4,7 +4,7 @@
 ####################################
 
 # TODO: replace it with device's BOOTCLASSPATH
-DEXPREOPT_BOOT_JARS := core:core-junit:bouncycastle:ext:framework:android.policy:services:apache-xml
+DEXPREOPT_BOOT_JARS := core:core-junit:bouncycastle:ext:framework:framework2:android.policy:services:apache-xml
 DEXPREOPT_BOOT_JARS_MODULES := $(subst :, ,$(DEXPREOPT_BOOT_JARS))
 
 DEXPREOPT_BUILD_DIR := $(OUT_DIR)
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/build/core/java.mk b/build/core/java.mk
--- a/build/core/java.mk	2012-08-10 03:24:16.000912682 +0000
+++ b/build/core/java.mk	2012-08-10 03:38:12.464933458 +0000
@@ -40,7 +40,7 @@ ifneq ($(LOCAL_SDK_VERSION),)
   endif
 else
   ifneq ($(LOCAL_NO_STANDARD_LIBRARIES),true)
-    LOCAL_JAVA_LIBRARIES := core core-junit ext framework $(LOCAL_JAVA_LIBRARIES)
+    LOCAL_JAVA_LIBRARIES := core core-junit ext framework framework2 $(LOCAL_JAVA_LIBRARIES)
   endif
 endif
 
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/build/core/pathmap.mk b/build/core/pathmap.mk
--- a/build/core/pathmap.mk	2012-08-10 03:24:16.004912681 +0000
+++ b/build/core/pathmap.mk	2012-08-10 03:28:37.272912689 +0000
@@ -84,6 +84,7 @@ JNI_H_INCLUDE := $(call include-path-for
 # is so common and the other framework libraries can have mutual
 # interdependencies.
 #
+# BEGIN privacy-added: privacy
 FRAMEWORKS_BASE_SUBDIRS := \
 	$(addsuffix /java, \
 	    core \
@@ -95,6 +96,7 @@ FRAMEWORKS_BASE_SUBDIRS := \
 	    media/mca/filterpacks \
 	    drm \
 	    opengl \
+	    privacy \
 	    sax \
 	    telephony \
 	    wifi \
@@ -102,6 +104,7 @@ FRAMEWORKS_BASE_SUBDIRS := \
 	    icu4j \
 	    voip \
 	 )
+# END privacy-added: privacy
 
 #
 # A version of FRAMEWORKS_BASE_SUBDIRS that is expanded to full paths from
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/build/core/user_tags.mk b/build/core/user_tags.mk
--- a/build/core/user_tags.mk	2012-08-10 03:24:16.004912681 +0000
+++ b/build/core/user_tags.mk	2012-08-10 03:38:20.752991525 +0000
@@ -123,6 +123,7 @@ GRANDFATHERED_USER_MODULES += \
 	exc_dump \
 	fastboot \
 	framework \
+	framework2 \
 	FrameworkCoreHostTests \
 	frameworks-core-util-lib \
 	fsck_msdos \
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/build/target/product/core.mk b/build/target/product/core.mk
--- a/build/target/product/core.mk	2012-08-10 03:24:15.964912682 +0000
+++ b/build/target/product/core.mk	2012-08-10 03:41:07.432911481 +0000
@@ -22,6 +22,7 @@ PRODUCT_PROPERTY_OVERRIDES := \
     ro.config.notification_sound=OnTheHunt.ogg \
     ro.config.alarm_alert=Alarm_Classic.ogg
 
+# BEGIN privacy-added: PDroid
 PRODUCT_PACKAGES := \
     ApplicationsProvider \
     BackupRestoreConfirmation \
@@ -35,6 +36,7 @@ PRODUCT_PACKAGES := \
     Home \
     KeyChain \
     MediaProvider \
+    PDroid \
     PackageInstaller \
     PicoTts \
     SettingsProvider \
@@ -60,6 +62,7 @@ PRODUCT_PACKAGES := \
     drmserver \
     dx \
     ext \
+    framework2 \
     framework-res \
     hprof-conv \
     icu.dat \
@@ -120,6 +123,7 @@ PRODUCT_PACKAGES := \
     sensorservice \
     lint \
     uiautomator
+# END privacy-added: PDroid
 
 PRODUCT_COPY_FILES += \
     system/core/rootdir/init.usb.rc:root/init.usb.rc \
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/build/target/product/security/privacy.x509.pem b/build/target/product/security/privacy.x509.pem
--- a/build/target/product/security/privacy.x509.pem	1970-01-01 00:00:00.000000000 +0000
+++ b/build/target/product/security/privacy.x509.pem	2012-08-10 03:28:37.276912687 +0000
@@ -0,0 +1,20 @@
+-----BEGIN CERTIFICATE-----
+MIIDNDCCAhwCCQCXWkdOAj3rWTANBgkqhkiG9w0BAQUFADBcMQswCQYDVQQGEwJE
+RTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0
+cyBQdHkgTHRkMRUwEwYDVQQDEwxTdnlhdG9zbGF2IEgwHhcNMTEwNzE0MjEyNTI2
+WhcNMzgxMTI4MjEyNTI2WjBcMQswCQYDVQQGEwJERTETMBEGA1UECBMKU29tZS1T
+dGF0ZTEhMB8GA1UEChMYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMRUwEwYDVQQD
+EwxTdnlhdG9zbGF2IEgwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDb
+i4kL71TqNRi0F5RjDVejPlnN1aiFtruvWiuvppcPjY9SNw6WaTfJS356yWBrorU6
+qZbqS0l5vl+CcMrm94F2gbTZamsHaUz7puGMLx3R/s3vvYSD8pPwzqhyLY+mSSK+
+cbhvthJMa4FJLFyHKlHj7l1wn8qeAr2ceKVF4w5SjwGl9hwSHA68TMeb9dWO87N7
+82p+D9fqU3I33Qf0ieiBiRYrEBHQtDwCMJNktNmmG9GyKyu8PVs2jhvJkNsga/Le
+y+0FPwRgKA0MgnKavliGxST76Sl98pimc9h+ZyedwXw2z+lk1Fh+qhuDBWaTgIJl
+C+yLqa+TAYqimUdUYSuvAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBAHI5T9gdsFh1
+X4g7eQVXBEyW11mpsqUh/Kl4PI/8xSzeon9DQcNc+oQJDAvtOoQXww1sYKUykmwr
+H7idjx6fMyygeUsvRy7clDBfdG+GR43QPkJSZT61ZGhZUbKKOPoAMnomNe2uL4LW
+4iU/1bkEQNKzV0iea663t3t5rr++lE2Ulm0LIDLgxlmuyvl/6e8kgRk/ojj/ZhIh
+IjEZjWwAJDRxGz7Kc19keecUtIE/fBZrkC+qRivnfqEuXH/MW7a18uYYtG25yFQp
+UJHQ0wBayhY9NKkcgVAABMdiNtKJIXdrkeKBKDSnuX7GErwy23adjZ5wFjxefm7P
+jjazBHHW1qc=
+-----END CERTIFICATE-----
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/external/gtest/include/gtest/internal/gtest-param-util.h b/external/gtest/include/gtest/internal/gtest-param-util.h
--- a/external/gtest/include/gtest/internal/gtest-param-util.h	2012-08-10 03:24:25.228912681 +0000
+++ b/external/gtest/include/gtest/internal/gtest-param-util.h	2012-08-10 03:38:43.504910033 +0000
@@ -37,6 +37,7 @@
 #include <iterator>
 #include <utility>
 #include <vector>
+#include <cstddef>
 
 // scripts/fuse_gtest.py depends on gtest's own header being #included
 // *unconditionally*.  Therefore these #includes cannot be moved
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/external/llvm/llvm-host-build.mk b/external/llvm/llvm-host-build.mk
--- a/external/llvm/llvm-host-build.mk	2012-08-10 03:24:39.864912681 +0000
+++ b/external/llvm/llvm-host-build.mk	2012-08-10 03:38:43.516911049 +0000
@@ -11,6 +11,8 @@ LOCAL_CFLAGS :=	\
 	-Wwrite-strings	\
 	$(LOCAL_CFLAGS)
 
+LOCAL_LDLIBS := -lpthread -ldl 
+
 ifeq ($(LLVM_ENABLE_ASSERTION),true)
 LOCAL_CFLAGS :=	\
 	$(LOCAL_CFLAGS) \
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/external/mesa3d/src/glsl/linker.cpp b/external/mesa3d/src/glsl/linker.cpp
--- a/external/mesa3d/src/glsl/linker.cpp	2012-08-10 03:24:24.816912681 +0000
+++ b/external/mesa3d/src/glsl/linker.cpp	2012-08-10 03:38:43.520911321 +0000
@@ -68,6 +68,7 @@
 #include <cstdio>
 #include <cstdarg>
 #include <climits>
+#include <stddef.h>
 
 #include <pixelflinger2/pixelflinger2_interface.h>
 
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/Android.mk b/frameworks/base/Android.mk
--- a/frameworks/base/Android.mk	2012-08-10 03:25:12.828912682 +0000
+++ b/frameworks/base/Android.mk	2012-08-10 04:19:59.572902306 +0000
@@ -28,10 +28,25 @@ framework_res_source_path := APPS/framew
 
 # the library
 # ============================================================
+#
+# These will be included in framework2 to avoid issues with the limit
+# on the number of classes/dex
+SECONDARY_FRAMEWORKS_SUBDIRS := \
+        core/java/android/test \
+        core/java/android/gesture \
+        core/java/android/speech/srec \
+        media/java/android/media/videoeditor \
+        media/java/android/media/audiofx \
+        media/mca/effect/java/android/media/effect \
+        media/mca/effect/java/android/media/effect/effects
+
 include $(CLEAR_VARS)
 
 # FRAMEWORKS_BASE_SUBDIRS comes from build/core/pathmap.mk
 LOCAL_SRC_FILES := $(call find-other-java-files,$(FRAMEWORKS_BASE_SUBDIRS))
+SECONDARY_SRC_FILES := $(call find-other-java-files,$(SECONDARY_FRAMEWORKS_SUBDIRS))
+
+LOCAL_SRC_FILES := $(filter-out $(SECONDARY_SRC_FILES),$(LOCAL_SRC_FILES))
 
 # EventLogTags files.
 LOCAL_SRC_FILES += \
@@ -58,6 +73,7 @@ LOCAL_SRC_FILES := $(filter-out \
 ## across process boundaries.
 ##
 ## READ ME: ########################################################
+# BEGIN privacy-added: IPrivacySettingsManager.aidl
 LOCAL_SRC_FILES += \
 	core/java/android/accessibilityservice/IAccessibilityServiceConnection.aidl \
 	core/java/android/accessibilityservice/IAccessibilityServiceClient.aidl \
@@ -198,6 +214,7 @@ LOCAL_SRC_FILES += \
 	media/java/android/media/IMediaScannerService.aidl \
 	media/java/android/media/IRemoteControlClient.aidl \
 	media/java/android/media/IRemoteControlDisplay.aidl \
+	privacy/java/android/privacy/IPrivacySettingsManager.aidl \
 	media/java/android/media/IRemoteVolumeObserver.aidl \
 	media/java/android/media/IRingtonePlayer.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl \
@@ -214,6 +231,7 @@ LOCAL_SRC_FILES += \
 	voip/java/android/net/sip/ISipSessionListener.aidl \
 	voip/java/android/net/sip/ISipService.aidl
 #
+# END privacy-added: IPrivacySettingsManager.aidl
 
 
 # FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
@@ -252,10 +270,12 @@ $(full_classes_compiled_jar): $(framewor
 $(LOCAL_INSTALLED_MODULE): | $(dir $(LOCAL_INSTALLED_MODULE))framework-res.apk
 
 framework_built := $(call java-lib-deps,framework)
+framework_built += $(call java-lib-deps,framework2)
 
 # AIDL files to be preprocessed and included in the SDK,
 # relative to the root of the build tree.
 # ============================================================
+# BEGIN privacy-added: PrivacySettings.aidl
 aidl_files := \
 	frameworks/base/core/java/android/accounts/IAccountManager.aidl \
 	frameworks/base/core/java/android/accounts/IAccountManagerResponse.aidl \
@@ -301,11 +321,13 @@ aidl_files := \
 	frameworks/base/graphics/java/android/graphics/Region.aidl \
 	frameworks/base/location/java/android/location/Criteria.aidl \
 	frameworks/base/location/java/android/location/Location.aidl \
+	frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl \
 	frameworks/base/telephony/java/android/telephony/ServiceState.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl \
 
 gen := $(TARGET_OUT_COMMON_INTERMEDIATES)/framework.aidl
+# END privacy-added: PrivacySettings.aidl
 $(gen): PRIVATE_SRC_FILES := $(aidl_files)
 ALL_SDK_FILES += $(gen)
 $(gen): $(aidl_files) | $(AIDL)
@@ -390,6 +412,7 @@ framework_docs_LOCAL_JAVA_LIBRARIES := \
 			core \
 			ext \
 			framework \
+			framework2 \
 
 framework_docs_LOCAL_MODULE_CLASS := JAVA_LIBRARIES
 framework_docs_LOCAL_DROIDDOC_HTML_DIR := docs/html
@@ -664,7 +687,7 @@ include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
 LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
-LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES) framework
+LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES) framework framework2
 LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
 LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
 LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
@@ -717,6 +740,26 @@ LOCAL_DX_FLAGS := --core-library
 
 include $(BUILD_JAVA_LIBRARY)
 
+include $(CLEAR_VARS)
+
+# FRAMEWORKS_BASE_SUBDIRS comes from build/core/pathmap.mk
+LOCAL_SRC_FILES := $(call find-other-java-files,$(SECONDARY_FRAMEWORKS_SUBDIRS))
+
+LOCAL_NO_STANDARD_LIBRARIES := true
+LOCAL_JAVA_LIBRARIES := bouncycastle core core-junit ext framework
+
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE := framework2
+LOCAL_MODULE_CLASS := JAVA_LIBRARIES
+
+LOCAL_NO_EMMA_INSTRUMENT := true
+LOCAL_NO_EMMA_COMPILE := true
+
+#LOCAL_JARJAR_RULES := $(LOCAL_PATH)/jarjar-rules.txt
+
+LOCAL_DX_FLAGS := --core-library
+
+include $(BUILD_JAVA_LIBRARY)
 
 # Include subdirectory makefiles
 # ============================================================
@@ -726,3 +769,4 @@ include $(BUILD_JAVA_LIBRARY)
 ifeq (,$(ONE_SHOT_MAKEFILE))
 include $(call first-makefiles-under,$(LOCAL_PATH))
 endif
+
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/core/java/android/app/ContextImpl.java b/frameworks/base/core/java/android/app/ContextImpl.java
--- a/frameworks/base/core/java/android/app/ContextImpl.java	2012-08-10 03:25:15.020912682 +0000
+++ b/frameworks/base/core/java/android/app/ContextImpl.java	2012-08-10 03:30:54.952896651 +0000
@@ -86,6 +86,13 @@ import android.os.ServiceManager;
 import android.os.UserId;
 import android.os.SystemVibrator;
 import android.os.storage.StorageManager;
+// BEGIN privacy-added
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.surrogate.PrivacyAccountManager;
+import android.privacy.surrogate.PrivacyLocationManager;
+import android.privacy.surrogate.PrivacyTelephonyManager;
+// END privacy-added
 import android.telephony.TelephonyManager;
 import android.content.ClipboardManager;
 import android.util.AndroidRuntimeException;
@@ -156,6 +163,7 @@ class ContextImpl extends Context {
     private Resources mResources;
     /*package*/ ActivityThread mMainThread;
     private Context mOuterContext;
+    private static Context sOuterContext;
     private IBinder mActivityToken = null;
     private ApplicationContentResolver mContentResolver;
     private int mThemeResource = 0;
@@ -269,7 +277,9 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(ACCOUNT_SERVICE);
                     IAccountManager service = IAccountManager.Stub.asInterface(b);
-                    return new AccountManager(ctx, service);
+                    // BEGIN privacy-modified
+                    return new PrivacyAccountManager(ctx, service);
+                    // END privacy-modified
                 }});
 
         registerService(ACTIVITY_SERVICE, new ServiceFetcher() {
@@ -364,7 +374,10 @@ class ContextImpl extends Context {
         registerService(LOCATION_SERVICE, new StaticServiceFetcher() {
                 public Object createStaticService() {
                     IBinder b = ServiceManager.getService(LOCATION_SERVICE);
-                    return new LocationManager(ILocationManager.Stub.asInterface(b));
+                    // BEGIN privacy-modified
+                    ILocationManager service = ILocationManager.Stub.asInterface(b);
+                    return new PrivacyLocationManager(service,getStaticOuterContext());
+                    // END privacy-modified
                 }});
 
         registerService(NETWORK_POLICY_SERVICE, new ServiceFetcher() {
@@ -434,7 +447,9 @@ class ContextImpl extends Context {
 
         registerService(TELEPHONY_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
-                    return new TelephonyManager(ctx.getOuterContext());
+                    // BEGIN privacy-modified
+                    return new PrivacyTelephonyManager(ctx.getOuterContext());
+                    // END privacy-modified
                 }});
 
         registerService(THROTTLE_SERVICE, new StaticServiceFetcher() {
@@ -485,6 +500,16 @@ class ContextImpl extends Context {
                 public Object getService(ContextImpl ctx) {
                     return WindowManagerImpl.getDefault(ctx.mPackageInfo.mCompatibilityInfo);
                 }});
+
+        // BEGIN privacy-added
+        registerService("privacy", new StaticServiceFetcher() {
+                public Object createStaticService() {
+                    IBinder b = ServiceManager.getService("privacy");
+                    IPrivacySettingsManager service = IPrivacySettingsManager.Stub.asInterface(b);
+                    return new PrivacySettingsManager(getStaticOuterContext(),service);
+                }});
+        // END privacy-added
+
     }
 
     static ContextImpl getImpl(Context context) {
@@ -1538,7 +1563,7 @@ class ContextImpl extends Context {
     }
 
     ContextImpl() {
-        mOuterContext = this;
+        sOuterContext = mOuterContext = this;
     }
 
     /**
@@ -1553,7 +1578,7 @@ class ContextImpl extends Context {
         mResources = context.mResources;
         mMainThread = context.mMainThread;
         mContentResolver = context.mContentResolver;
-        mOuterContext = this;
+        sOuterContext = mOuterContext = this;
     }
 
     final void init(LoadedApk packageInfo,
@@ -1613,13 +1638,17 @@ class ContextImpl extends Context {
     }
 
     final void setOuterContext(Context context) {
-        mOuterContext = context;
+        sOuterContext = mOuterContext = context;
     }
 
     final Context getOuterContext() {
         return mOuterContext;
     }
 
+    final static Context getStaticOuterContext() {
+        return sOuterContext;
+    }
+
     final IBinder getActivityToken() {
         return mActivityToken;
     }
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/core/java/android/content/ContentResolver.java b/frameworks/base/core/java/android/content/ContentResolver.java
--- a/frameworks/base/core/java/android/content/ContentResolver.java	2012-08-10 03:25:15.540912681 +0000
+++ b/frameworks/base/core/java/android/content/ContentResolver.java	2012-08-10 03:30:54.960898703 +0000
@@ -39,6 +39,9 @@ import android.os.ParcelFileDescriptor;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.SystemClock;
+// BEGIN privacy-added
+import android.privacy.surrogate.PrivacyContentResolver;
+// END privacy-added
 import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/preloaded-classes b/frameworks/base/preloaded-classes
--- a/frameworks/base/preloaded-classes	2012-08-10 03:25:10.860912682 +0000
+++ b/frameworks/base/preloaded-classes	2012-08-10 03:30:54.960898703 +0000
@@ -652,6 +652,10 @@ android.provider.Settings$NameValueCache
 android.provider.Settings$NameValueTable
 android.provider.Settings$Secure
 android.provider.Settings$System
+# BEGIN privacy-added
+android.privacy.PrivacySettingsManager
+android.privacy.PrivacySettings
+# END privacy-added
 android.renderscript.RenderScript
 android.server.BluetoothA2dpService
 android.server.BluetoothEventLoop
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/IPrivacySettingsManager.aidl b/frameworks/base/privacy/java/android/privacy/IPrivacySettingsManager.aidl
--- a/frameworks/base/privacy/java/android/privacy/IPrivacySettingsManager.aidl	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/IPrivacySettingsManager.aidl	2012-08-10 03:30:54.964899590 +0000
@@ -0,0 +1,18 @@
+package android.privacy;
+import android.privacy.PrivacySettings;
+
+/** {@hide} */
+interface IPrivacySettingsManager
+{
+    PrivacySettings getSettings(String packageName);
+    boolean saveSettings(in PrivacySettings settings);
+    boolean deleteSettings(String packageName);
+    void notification(String packageName, byte accessMode, String dataType, String output);
+    void registerObservers();
+    void addObserver(String packageName);
+    boolean purgeSettings();
+    double getVersion();
+    boolean setEnabled(boolean enable);
+    boolean setNotificationsEnabled(boolean enable);
+    void setBootCompleted();
+}
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/PrivacyFileObserver.java b/frameworks/base/privacy/java/android/privacy/PrivacyFileObserver.java
--- a/frameworks/base/privacy/java/android/privacy/PrivacyFileObserver.java	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/PrivacyFileObserver.java	2012-08-10 03:30:54.972901301 +0000
@@ -0,0 +1,89 @@
+package android.privacy;
+
+import android.os.FileObserver;
+import android.util.Log;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.StringTokenizer;
+
+/** {@hide} */
+public class PrivacyFileObserver extends FileObserver {
+    
+    public static final String TAG = "PrivacyFileObserver";
+    
+    public static final int PACKAGE_PATH_INDEX = 3;
+    
+    public String absolutePath;
+    
+    private PrivacySettingsManagerService pSetManServ;
+    
+    public HashMap<String, PrivacyFileObserver> children; 
+    
+    public PrivacyFileObserver(String path, PrivacySettingsManagerService pSetManServ) {
+        super(path, FileObserver.ALL_EVENTS);
+        this.absolutePath = path;
+        this.pSetManServ = pSetManServ;
+        
+        this.children = new HashMap<String, PrivacyFileObserver>();
+        File thisFile = new File(absolutePath);
+        if (thisFile.isDirectory()) {
+            File[] subfiles = thisFile.listFiles();
+            for (File file : subfiles) {
+                String observePath = file.getAbsolutePath();
+                PrivacyFileObserver child = new PrivacyFileObserver(observePath, pSetManServ);
+                children.put(observePath, child);
+                // don't watch directories, only the settings files
+                if (file.isFile()) child.startWatching();
+            }
+        }
+        
+    }
+
+    @Override
+    public void onEvent(int event, String path) {
+        if ((FileObserver.ACCESS & event) != 0) { // data was read from a file
+//            Log.d(TAG, "onEvent - file accessed: " + absolutePath);
+            StringTokenizer tokenizer = new StringTokenizer(absolutePath, "/");
+            for (int i = 0; i < PACKAGE_PATH_INDEX && tokenizer.hasMoreElements(); i++) {
+                tokenizer.nextToken();
+            }
+            
+            // get the package and UID of accessing application
+            String packageName = tokenizer.nextToken();
+//            int uid = 0;
+//            try {
+//                uid = Integer.parseInt(tokenizer.nextToken());
+//            } catch (NumberFormatException e) {
+//                Log.e(TAG, "onEvent - could not get the UID of accessing application", e);
+//                // we still can continue, UID is optional here
+//            }
+            
+            // read the setting
+            PrivacySettings pSet = pSetManServ.getSettings(packageName);
+            pSetManServ.notification(packageName, pSet.getSystemLogsSetting(), PrivacySettings.DATA_SYSTEM_LOGS, null);
+        }
+        
+    }
+    
+    public void addObserver(String relativePath) {
+        String observePath = absolutePath + "/" + relativePath;
+        // remove existing observer(s) if any
+        children.remove(observePath); // child observers should be destroyed at next GC
+        // create new observer(s)
+        PrivacyFileObserver child = new PrivacyFileObserver(observePath, pSetManServ);
+        children.put(observePath, child);
+    }
+
+    @Override
+    public void startWatching() {
+//        Log.d("PrivacyFileObserver", "PrivacyFileObserver - observing directory: " + absolutePath);
+        super.startWatching();
+    }
+    
+//    public void verifyObserver() {
+//        Log.d(TAG, "verifyObservers - observer path: " + absolutePath);
+//        for (PrivacyFileObserver obs : children.values()) obs.verifyObserver();
+//    }
+    
+}
\ No newline at end of file
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/PrivacyPersistenceAdapter.java b/frameworks/base/privacy/java/android/privacy/PrivacyPersistenceAdapter.java
--- a/frameworks/base/privacy/java/android/privacy/PrivacyPersistenceAdapter.java	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/PrivacyPersistenceAdapter.java	2012-08-10 03:30:54.980902750 +0000
@@ -0,0 +1,792 @@
+package android.privacy;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.os.FileUtils;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Responsible for persisting privacy settings to built-in memory
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public class PrivacyPersistenceAdapter {
+
+    private static final String TAG = "PrivacyPersistenceAdapter";
+    
+    private static final int RETRY_QUERY_COUNT = 5;
+
+    private static final String DATABASE_FILE = "/data/system/privacy.db";
+    
+    private static final int DATABASE_VERSION = 3;
+    
+    public static final int DUMMY_UID = -1;
+    
+    /**
+     * Number of threads currently reading the database
+     */
+    public static Integer readingThreads = 0;
+    
+    /**
+     * Used to save settings for access from core libraries
+     */
+    public static final String SETTINGS_DIRECTORY = "/data/system/privacy";
+
+    private static final String TABLE_SETTINGS = "settings";
+    
+    private static final String TABLE_MAP = "map";
+    
+    private static final String TABLE_ALLOWED_CONTACTS = "allowed_contacts";
+    
+    private static final String TABLE_VERSION = "version";
+    
+    private static final String CREATE_TABLE_SETTINGS = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_SETTINGS + " ( " + 
+        " _id INTEGER PRIMARY KEY AUTOINCREMENT, " + 
+        " packageName TEXT, " + 
+        " uid INTEGER, " + 
+        " deviceIdSetting INTEGER, " + 
+        " deviceId TEXT, " + 
+        " line1NumberSetting INTEGER, " + 
+        " line1Number TEXT, " + 
+        " locationGpsSetting INTEGER, " + 
+        " locationGpsLat TEXT, " + 
+        " locationGpsLon TEXT, " + 
+        " locationNetworkSetting INTEGER, " + 
+        " locationNetworkLat TEXT, " + 
+        " locationNetworkLon TEXT, " + 
+        " networkInfoSetting INTEGER, " + 
+        " simInfoSetting INTEGER, " + 
+        " simSerialNumberSetting INTEGER, " + 
+        " simSerialNumber TEXT, " + 
+        " subscriberIdSetting INTEGER, " + 
+        " subscriberId TEXT, " + 
+        " accountsSetting INTEGER, " + 
+        " accountsAuthTokensSetting INTEGER, " + 
+        " outgoingCallsSetting INTEGER, " + 
+        " incomingCallsSetting INTEGER, " + 
+        " contactsSetting INTEGER, " + 
+        " calendarSetting INTEGER, " + 
+        " mmsSetting INTEGER, " + 
+        " smsSetting INTEGER, " + 
+        " callLogSetting INTEGER, " + 
+        " bookmarksSetting INTEGER, " + 
+        " systemLogsSetting INTEGER, " + 
+        " externalStorageSetting INTEGER, " + 
+        " cameraSetting INTEGER, " + 
+        " recordAudioSetting INTEGER, " + 
+        " notificationSetting INTEGER, " + 
+        " intentBootCompletedSetting INTEGER" + 
+        ");";
+    
+    private static final String CREATE_TABLE_MAP = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_MAP + " ( name TEXT PRIMARY KEY, value TEXT );";
+    
+    private static final String CREATE_TABLE_ALLOWED_CONTACTS = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_ALLOWED_CONTACTS + " ( settings_id, contact_id, PRIMARY KEY(settings_id, contact_id) );";
+    
+    private static final String INSERT_VERSION = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"db_version\", " + DATABASE_VERSION + ");";
+    
+    private static final String INSERT_ENABLED = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"enabled\", \"1\");";
+    
+    private static final String INSERT_NOTIFICATIONS_ENABLED = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"notifications_enabled\", \"1\");";
+    
+    private static final String[] DATABASE_FIELDS = new String[] { "_id", "packageName", "uid", 
+        "deviceIdSetting", "deviceId", "line1NumberSetting", "line1Number", "locationGpsSetting", 
+        "locationGpsLat", "locationGpsLon", "locationNetworkSetting", "locationNetworkLat", 
+        "locationNetworkLon", "networkInfoSetting", "simInfoSetting", "simSerialNumberSetting", 
+        "simSerialNumber", "subscriberIdSetting", "subscriberId", "accountsSetting", "accountsAuthTokensSetting", 
+        "outgoingCallsSetting", "incomingCallsSetting", "contactsSetting", "calendarSetting", 
+        "mmsSetting", "smsSetting", "callLogSetting", "bookmarksSetting", "systemLogsSetting", 
+        "externalStorageSetting", "cameraSetting", "recordAudioSetting", "notificationSetting", 
+        "intentBootCompletedSetting" };
+    
+    public static final String SETTING_ENABLED = "enabled";
+    public static final String SETTING_NOTIFICATIONS_ENABLED = "notifications_enabled";
+    public static final String SETTING_DB_VERSION = "db_version";
+    public static final String VALUE_TRUE = "1";
+    public static final String VALUE_FALSE = "0";
+
+    private SQLiteDatabase db;
+    
+    private Context context;
+
+    public PrivacyPersistenceAdapter(Context context) {
+        this.context = context;
+        // check write permission for /data/system/
+        boolean canWrite = new File("/data/system/").canWrite();
+//        Log.d(TAG, "Constructing " + TAG + " for package: " +  context.getPackageName() + 
+//                " UID: " + Binder.getCallingUid() + "; Write permission for /data/system/: " + canWrite);
+        // create the database and settings directory if we have write permission and they do not exist
+        if (canWrite) {
+            if (!new File(DATABASE_FILE).exists()) createDatabase();
+            if (!new File(SETTINGS_DIRECTORY).exists()) createSettingsDir();
+            // upgrade if needed
+            int currentVersion = getDbVersion();
+//            Log.d(TAG, "PrivacyPersistenceAdapter - current DB version: " + currentVersion);
+            if (currentVersion < DATABASE_VERSION) upgradeDatabase(currentVersion);
+        }
+    }
+
+    private synchronized void upgradeDatabase(int currentVersion) {
+        Log.i(TAG, "upgradeDatabase - upgrading DB from version " + currentVersion + " to " + DATABASE_VERSION);
+        
+        // backup current database file
+        File dbFile = new File(DATABASE_FILE);
+        File dbBackupFile = new File(DATABASE_FILE + ".bak");
+        // remove old backup
+        try {
+            dbBackupFile.delete();
+        } catch (SecurityException e) {
+            Log.w(TAG, "upgradeDatabase - could not remove old backup");
+        }
+        // backup current DB file
+        FileUtils.copyFile(dbFile, dbBackupFile);
+        // make sure a backup was created
+        if (System.currentTimeMillis() - dbBackupFile.lastModified() > 2000) {
+            Log.e(TAG, "upgradeDatabase - could not create a database backup, aborting...");
+            return;
+        }
+        
+        SQLiteDatabase db = getWritableDatabase();
+        db.beginTransaction();
+        
+        switch (currentVersion) {
+            case 1:
+            case 2:
+                try {
+                    if (db != null && db.isOpen()) {
+                        db.execSQL("DROP TABLE IF EXISTS " + TABLE_VERSION + ";");
+                        db.execSQL(CREATE_TABLE_ALLOWED_CONTACTS); 
+                        db.execSQL(CREATE_TABLE_MAP);
+                        db.execSQL(INSERT_VERSION);
+                        db.execSQL(INSERT_ENABLED);
+                        db.execSQL(INSERT_NOTIFICATIONS_ENABLED);
+                        
+                        // remove uid dirs from the settings directory
+                        File settingsDir = new File(SETTINGS_DIRECTORY);
+                        for (File packageDir : settingsDir.listFiles()) {
+                            for (File uidDir : packageDir.listFiles()) {
+                                if (uidDir.isDirectory()) {
+                                    File[] settingsFiles = uidDir.listFiles();
+                                    // copy the first found (most likely the only one) one level up
+                                    if (settingsFiles[0] != null) {
+                                        File newPath = new File(packageDir + "/" + settingsFiles[0].getName());
+                                        newPath.delete();
+                                        settingsFiles[0].renameTo(newPath);
+                                        deleteRecursive(uidDir);
+                                    }
+                                }
+                            }
+                        }
+                        
+                        db.setTransactionSuccessful();
+                    }
+                } catch (Exception e) {
+                    if (db != null && db.isOpen()) {
+                        db.endTransaction();
+                        db.close();
+                    }
+                    Log.w(TAG, "upgradeDatabase - could not upgrade DB; will restore backup", e);
+                    FileUtils.copyFile(dbBackupFile, dbFile);
+                    dbBackupFile.delete();
+                }
+                
+                
+                break;
+                
+            case 3:
+                // most current version, do nothing
+                Log.w(TAG, "upgradeDatabase - trying to upgrade most current DB version");
+                break;
+        }
+        
+        if (db != null && db.isOpen()) {
+            db.endTransaction();
+            db.close();
+        } else {
+            Log.e(TAG, "upgradeDatabase - database is null or closed; cant call endTransaction()");
+        }
+        
+        purgeSettings();
+    }
+    
+    private int getDbVersion() {
+        int version = -1;
+        // check if the table "map" exists; if it doesn't -> return version 1
+        readingThreads++;
+        SQLiteDatabase db = getReadableDatabase();
+        try {
+            Cursor c = rawQuery(db, "SELECT name FROM sqlite_master WHERE type='table' AND name='" + TABLE_MAP + "';");
+            if (c != null) {
+                if (c.getCount() == 0) {
+                    // table map does not exist
+                    version = 1;
+                }
+                c.close();
+                synchronized (readingThreads) {
+                    readingThreads--;
+                    // only close DB if no other threads are reading
+                    if (readingThreads == 0 && db != null && db.isOpen()) {
+                        db.close();
+                    }
+                }
+            } else {
+                Log.e(TAG, "getDbVersion - failed to check if table map exists (cursor is null)");
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "getDbVersion - failed to check if table map exists (exception)");
+        }
+        if (version == 1) return version;
+        
+        String versionString = getValue(SETTING_DB_VERSION);
+        if (versionString == null) return 1;
+        
+        int versionNum;
+        try {
+            versionNum = Integer.parseInt(versionString);
+        } catch (Exception e) {
+            Log.e(TAG, "getDbVersion - failed to parse database version; returning 1");
+            return 1;
+        }
+        
+        return versionNum;
+    }
+    
+    public String getValue(String name) {
+        readingThreads++;
+        SQLiteDatabase db = getReadableDatabase();
+        Cursor c;
+        String output = null;
+        
+        try {
+            c = query(db, TABLE_MAP, new String[] { "value" }, "name=?", 
+                    new String[] { name }, null, null, null, null);
+            if (c != null && c.getCount() > 0 && c.moveToFirst()) {
+                output = c.getString(c.getColumnIndex("value"));
+                c.close();
+            } else {
+                Log.w(TAG, "getValue - could not get value for name: " + name);
+            }
+        } catch (Exception e) {
+            Log.w(TAG, "getValue - could not get value for name: " + name, e);
+        }
+        
+        synchronized (readingThreads) {
+            readingThreads--;
+            // only close DB if no other threads are reading
+            if (readingThreads == 0 && db != null && db.isOpen()) {
+                db.close();
+            }
+        }
+        return output;
+    }
+    
+    public synchronized boolean setValue(String name, String value) {
+        Log.e(TAG, "setValue - name " + name + " value " + value);
+        ContentValues values = new ContentValues();
+        values.put("name", name);
+        values.put("value", value);
+        SQLiteDatabase db = getWritableDatabase();
+        boolean success = db.replace(TABLE_MAP, null, values) != -1;
+        if (readingThreads == 0 && db != null && db.isOpen()) db.close();
+        return success;
+    }
+    
+    public PrivacySettings getSettings(String packageName, boolean forceCloseDB) {
+        PrivacySettings s = null;
+        
+        if (packageName == null) {
+            Log.e(TAG, "getSettings - insufficient application identifier - package name is required");
+            return s;
+        }
+        
+        // indicate that the DB is being read to prevent closing by other threads
+        readingThreads++;
+//        Log.d(TAG, "getSettings - settings request for package: " + packageName + " readingThreads: " + readingThreads);
+        
+        SQLiteDatabase db;
+        try {
+            db = getReadableDatabase();
+        } catch (SQLiteException e) {
+            Log.e(TAG, "getSettings - database could not be opened", e);
+            readingThreads--;
+            return s;
+        }
+            
+        Cursor c = null;
+
+        try {
+            c = query(db, TABLE_SETTINGS, DATABASE_FIELDS, "packageName=?", new String[] { packageName }, null, null, null, null);
+
+            if (c != null && c.moveToFirst()) {
+                s = new PrivacySettings(c.getInt(0), c.getString(1), c.getInt(2), (byte)c.getShort(3), c.getString(4), 
+                        (byte)c.getShort(5), c.getString(6), (byte)c.getShort(7), c.getString(8), c.getString(9), (byte)c.getShort(10), 
+                        c.getString(11), c.getString(12), (byte)c.getShort(13), (byte)c.getShort(14), (byte)c.getShort(15), 
+                        c.getString(16), (byte)c.getShort(17), c.getString(18), (byte)c.getShort(19), (byte)c.getShort(20), 
+                        (byte)c.getShort(21), (byte)c.getShort(22), (byte)c.getShort(23), (byte)c.getShort(24), (byte)c.getShort(25), 
+                        (byte)c.getShort(26), (byte)c.getShort(27), (byte)c.getShort(28), (byte)c.getShort(29), (byte)c.getShort(30), 
+                        (byte)c.getShort(31), (byte)c.getShort(32), (byte)c.getShort(33), (byte)c.getShort(34), null);
+                
+                // get allowed contacts IDs if necessary
+//                Log.d(TAG, "getSettings - looking for allowed contacts for " + s.get_id());
+//                c = query(db, TABLE_ALLOWED_CONTACTS, null, 
+//                        "settings_id=?", new String[] { Integer.toString(s.get_id()) }, null, null, null, null);
+                c = rawQuery(db, "SELECT * FROM allowed_contacts WHERE settings_id=" + Integer.toString(s.get_id()) + ";");
+                
+                if (c != null && c.getCount() > 0) {
+//                    Log.d(TAG, "getSettings - found allowed contacts");
+                    int[] allowedContacts = new int[c.getCount()];
+                    while (c.moveToNext()) allowedContacts[c.getPosition()] = c.getInt(1);
+                    s.setAllowedContacts(allowedContacts);
+                }
+//                    Log.d(TAG, "getSettings - found settings entry for package: " + packageName + " UID: " + uid);
+            } 
+//            else {
+//                Log.e(TAG, "getSettings - no settings found for package: " + packageName);
+//            }
+        } catch (Exception e) {
+            Log.e(TAG, "getSettings - failed to get settings for package: " + packageName, e);
+            e.printStackTrace();
+            if (c != null) c.close();
+        } finally {
+            if (c != null) c.close();
+//            if (forceCloseDB && db != null && db.isOpen()) {
+//                db.close();
+//            } else {
+            synchronized (readingThreads) {
+                readingThreads--;
+                // only close DB if no other threads are reading
+                if (readingThreads == 0 && db != null && db.isOpen()) {
+                    db.close();
+                }
+            }
+//            }
+        }
+        
+//        Log.d(TAG, "getSettings - returning settings: " + s);
+        return s;
+    }
+    
+    /**
+     * Saves the settings object fields into DB and into plain text files where applicable. 
+     * The DB changes will not be made persistent if saving settings to plain text files
+     * fails.
+     * @param s settings object
+     * @return true if settings were saved successfully, false otherwise
+     */
+    public synchronized boolean saveSettings(PrivacySettings s) {
+        boolean result = true;
+        String packageName = s.getPackageName();
+//        Integer uid = s.getUid();
+//        Log.d(TAG, "saveSettings - settings save request : " + s);
+        
+        if (packageName == null || packageName.isEmpty()/* || uid == null*/) {
+            Log.e(TAG, "saveSettings - either package name, UID or both is missing");
+            return false;
+        }
+
+        ContentValues values = new ContentValues();
+        values.put("packageName", packageName);
+//        values.put("uid", uid);
+        values.put("uid", DUMMY_UID);
+        
+        values.put("deviceIdSetting", s.getDeviceIdSetting());
+        values.put("deviceId", s.getDeviceId());
+        
+        values.put("line1NumberSetting", s.getLine1NumberSetting());
+        values.put("line1Number", s.getLine1Number());
+        
+        values.put("locationGpsSetting", s.getLocationGpsSetting());
+        values.put("locationGpsLat", s.getLocationGpsLat());
+        values.put("locationGpsLon", s.getLocationGpsLon());
+        
+        values.put("locationNetworkSetting", s.getLocationNetworkSetting());
+        values.put("locationNetworkLat", s.getLocationNetworkLat());
+        values.put("locationNetworkLon", s.getLocationNetworkLon());
+        
+        values.put("networkInfoSetting", s.getNetworkInfoSetting());        
+        values.put("simInfoSetting", s.getSimInfoSetting());
+        
+        values.put("simSerialNumberSetting", s.getSimSerialNumberSetting());        
+        values.put("simSerialNumber", s.getSimSerialNumber());
+        values.put("subscriberIdSetting", s.getSubscriberIdSetting());        
+        values.put("subscriberId", s.getSubscriberId());
+        
+        values.put("accountsSetting", s.getAccountsSetting());
+        values.put("accountsAuthTokensSetting", s.getAccountsAuthTokensSetting());
+        values.put("outgoingCallsSetting", s.getOutgoingCallsSetting());
+        values.put("incomingCallsSetting", s.getIncomingCallsSetting());
+        
+        values.put("contactsSetting", s.getContactsSetting());
+        values.put("calendarSetting", s.getCalendarSetting());
+        values.put("mmsSetting", s.getMmsSetting());
+        values.put("smsSetting", s.getSmsSetting());
+        values.put("callLogSetting", s.getCallLogSetting());
+        values.put("bookmarksSetting", s.getBookmarksSetting());
+        values.put("systemLogsSetting", s.getSystemLogsSetting());
+        values.put("notificationSetting", s.getNotificationSetting());
+        values.put("intentBootCompletedSetting", s.getIntentBootCompletedSetting());
+//        values.put("externalStorageSetting", s.getExternalStorageSetting());
+//        values.put("cameraSetting", s.getCameraSetting());
+//        values.put("recordAudioSetting", s.getRecordAudioSetting());
+        
+        readingThreads++;
+        SQLiteDatabase db = getWritableDatabase();
+        db.beginTransaction(); // make sure this ends up in a consistent state (DB and plain text files)
+        Cursor c = null;
+        try {
+            // save settings to the DB
+//            Log.d(TAG, "saveSettings - checking if entry exists already");
+            Integer id = s.get_id();
+            if (id != null) { // existing entry -> update
+//                Log.d(TAG, "saveSettings - updating existing entry");
+                if (db.update(TABLE_SETTINGS, values, "_id=?", new String[] { id.toString() }) < 1) {
+                    throw new Exception("saveSettings - failed to update database entry");
+                }
+                
+                db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { id.toString() });
+                int[] allowedContacts = s.getAllowedContacts();
+                if (allowedContacts != null) {
+                    ContentValues contactsValues = new ContentValues();
+                    for (int i = 0; i < allowedContacts.length; i++) {
+                        contactsValues.put("settings_id", id);
+                        contactsValues.put("contact_id", allowedContacts[i]);
+                        if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                            throw new Exception("saveSettings - failed to update database entry (contacts)");
+                    }
+                }
+
+            } else { // new entry -> insert if no duplicates exist
+//                Log.d(TAG, "saveSettings - new entry; verifying if duplicates exist");
+                c = db.query(TABLE_SETTINGS, new String[] { "_id" }, "packageName=?", 
+                        new String[] { s.getPackageName() }, null, null, null);
+                
+                if (c != null) {
+                    if (c.getCount() == 1) { // exactly one entry
+                        // exists -> update
+//                        Log.d(TAG, "saveSettings - updating existing entry");
+                        if (db.update(TABLE_SETTINGS, values, "packageName=?", 
+                                new String[] { s.getPackageName() }) < 1) {
+                            throw new Exception("saveSettings - failed to update database entry");
+                        }
+                        
+                        if (c.moveToFirst()) {
+                            Integer idAlt = c.getInt(0); // id of the found duplicate entry
+                            db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { idAlt.toString() });
+                            int[] allowedContacts = s.getAllowedContacts();
+                            if (allowedContacts != null) {
+                                ContentValues contactsValues = new ContentValues();
+                                for (int i = 0; i < allowedContacts.length; i++) {
+                                    contactsValues.put("settings_id", idAlt);
+                                    contactsValues.put("contact_id", allowedContacts[i]);
+                                    if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                                        throw new Exception("saveSettings - failed to update database entry (contacts)");
+                                }
+                            }    
+                        }
+                    } else if (c.getCount() == 0) { // no entries -> insert
+//                        Log.d(TAG, "saveSettings - inserting new entry");
+                        long rowId = db.insert(TABLE_SETTINGS, null, values);
+                        if (rowId == -1) {
+                            throw new Exception("saveSettings - failed to insert new record into DB");
+                        }
+                        
+                        db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { Long.toString(rowId) });
+                        int[] allowedContacts = s.getAllowedContacts();
+                        if (allowedContacts != null) {
+                            ContentValues contactsValues = new ContentValues();
+                            for (int i = 0; i < allowedContacts.length; i++) {
+                                contactsValues.put("settings_id", rowId);
+                                contactsValues.put("contact_id", allowedContacts[i]);
+                                if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                                    throw new Exception("saveSettings - failed to update database entry (contacts)");
+                            }
+                        }                        
+                    } else { // something went totally wrong and there are multiple entries for same identifier
+                        result = false;
+                        throw new Exception("saveSettings - duplicate entries in the privacy.db");
+                    }
+                } else {
+                    result = false;
+                    // jump to catch block to avoid marking transaction as successful
+                    throw new Exception("saveSettings - cursor is null, database access failed");
+                }
+            }
+            
+            // save settings to plain text file (for access from core libraries)
+//            Log.d(TAG, "saveSettings - saving to plain text file");
+//            File settingsUidDir = new File("/data/system/privacy/" + packageName + "/" + uid + "/");
+            File settingsPackageDir = new File("/data/system/privacy/" + packageName + "/");
+            File systemLogsSettingFile = new File("/data/system/privacy/" + packageName + "/" + "/systemLogsSetting");
+            try {
+                // create all parent directories on the file path
+//                settingsUidDir.mkdirs();
+                // make the directory readable (requires it to be executable as well)
+//                settingsUidDir.setReadable(true, false);
+//                settingsUidDir.setExecutable(true, false);
+                // make the parent directory readable (requires it to be executable as well)
+                settingsPackageDir.mkdirs();
+                settingsPackageDir.setReadable(true, false);
+                settingsPackageDir.setExecutable(true, false);
+                // create the setting files and make them readable
+                systemLogsSettingFile.createNewFile();
+                systemLogsSettingFile.setReadable(true, false);
+                // write settings to files
+//                Log.d(TAG, "saveSettings - writing to file");
+                OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(systemLogsSettingFile));
+                writer.append(s.getSystemLogsSetting() + "");
+                writer.flush();
+                writer.close();
+            } catch (IOException e) {
+                result = false;
+                // jump to catch block to avoid marking transaction as successful
+                throw new Exception("saveSettings - could not write settings to file", e);
+            }
+            // mark DB transaction successful (commit the changes)
+            db.setTransactionSuccessful();
+//            Log.d(TAG, "saveSettings - completing transaction");
+        } catch (Exception e) {
+            result = false;
+//            Log.d(TAG, "saveSettings - could not save settings", e);
+        } finally {
+            db.endTransaction();
+            if (c != null) c.close();
+            synchronized (readingThreads) {
+                readingThreads--;
+                // only close DB if no other threads are reading
+                if (readingThreads == 0 && db != null && db.isOpen()) {
+                    db.close();
+                }
+            }
+        }
+
+        return result;
+    }
+    
+    /**
+     * Deletes a settings entry from the DB
+     * @return true if settings were deleted successfully, false otherwise
+     */
+    public synchronized boolean deleteSettings(String packageName) {
+        boolean result = true;
+        
+        SQLiteDatabase db = getWritableDatabase();
+        db.beginTransaction(); // make sure this ends up in a consistent state (DB and plain text files)
+        try {
+//            Log.d(TAG, "deleteSettings - deleting database entry for " + packageName + " (" + uid + ")");
+            // try deleting contacts allowed entries; do not fail if deletion not possible
+            Cursor c = db.query(TABLE_SETTINGS, new String[] { "_id" }, "packageName=?", 
+                    new String[] { packageName }, null, null, null);
+            if (c != null && c.getCount() > 0 && c.moveToFirst()) {
+                int id = c.getInt(0);
+                db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { Integer.toString(id) });
+                c.close();
+            }
+            
+            if (db.delete(TABLE_SETTINGS, "packageName=?", new String[] { packageName }) == 0) {
+                Log.e(TAG, "deleteSettings - database entry for " + packageName + " not found");
+                return false;
+            }
+            
+            // delete settings from plain text file (for access from core libraries)
+//            File settingsUidDir = new File("/data/system/privacy/" + packageName + "/" + uid + "/");
+            File settingsPackageDir = new File("/data/system/privacy/" + packageName + "/");
+            File systemLogsSettingFile = new File("/data/system/privacy/" + packageName + "/systemLogsSetting");
+            // delete the setting files
+            systemLogsSettingFile.delete();
+            // delete the parent directories
+//            settingsUidDir.delete();
+            if (settingsPackageDir.list() == null || settingsPackageDir.list().length == 0) settingsPackageDir.delete();
+            // mark DB transaction successful (commit the changes)
+            db.setTransactionSuccessful();
+        } catch (Exception e) {
+            result = false;
+            Log.e(TAG, "deleteSettings - could not delete settings", e);
+        } finally {
+            db.endTransaction();
+            if (db != null && db.isOpen()) db.close();
+        }
+        
+        return result;
+    }
+    
+    private Cursor query(SQLiteDatabase db, String table, String[] columns, String selection, 
+            String[] selectionArgs, String groupBy, String having, String orderBy, String limit) throws Exception {
+        Cursor c = null;
+        // make sure getting settings does not fail because of IllegalStateException (db already closed)
+        boolean success = false;
+        for (int i = 0; success == false && i < RETRY_QUERY_COUNT; i++) {
+            try {
+                if (c != null) c.close();
+                c = db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+                success = true;
+            } catch (IllegalStateException e) {
+                success = false;
+                if (db != null && db.isOpen()) db.close();
+                db = getReadableDatabase();
+            }
+        }
+        if (success == false) throw new Exception("query - failed to execute query on the DB");
+        return c;
+    }
+    
+    private Cursor rawQuery(SQLiteDatabase db, String sql) throws Exception {
+        Cursor c = null;
+        // make sure getting settings does not fail because of IllegalStateException (db already closed)
+        boolean success = false;
+        for (int i = 0; success == false && i < RETRY_QUERY_COUNT; i++) {
+            try {
+                if (c != null) c.close();
+                c = db.rawQuery(sql, null);
+                success = true;
+            } catch (IllegalStateException e) {
+                success = false;
+                if (db != null && db.isOpen()) db.close();
+                db = getReadableDatabase();
+            }
+        }
+        if (success == false) throw new Exception("query - failed to execute query on the DB");
+        return c;
+    }
+    
+    /**
+     * Removes obsolete entries from the DB and file system. Should not be used in methods, which rely on the DB
+     * being open after this method has finished. It will close the DB if no other threads has increased
+     * the readingThread count.
+     * @return true if purge was successful, false otherwise.
+     */
+    public boolean purgeSettings() {
+        boolean result = true;
+//        Log.d(TAG, "purgeSettings - begin purging settings");
+        // get installed apps
+        List<String> apps = new ArrayList<String>();
+        PackageManager pMan = context.getPackageManager();
+        List<ApplicationInfo> installedApps = pMan.getInstalledApplications(PackageManager.GET_META_DATA);
+        for (ApplicationInfo appInfo : installedApps) { 
+            apps.add(appInfo.packageName);
+        }
+        
+//        Log.d(TAG, "purgeSettings - purging directories");
+        // delete obsolete settings directories
+        File settingsDir = new File(SETTINGS_DIRECTORY);
+        for (File packageDir : settingsDir.listFiles()) {
+            String packageName = packageDir.getName();
+//            Log.d(TAG, "purgeSettings - checking package directory " + packageName);
+            
+            if (!apps.contains(packageName)) { // remove package dir if no such app installed
+//                Log.d(TAG, "purgeSettings - deleting " + packageName);
+                deleteRecursive(packageDir);
+            } 
+        }
+        
+//        Log.d(TAG, "purgeSettings - purging database");
+        // delete obsolete entries from DB and update outdated entries
+        readingThreads++;
+        SQLiteDatabase db = getReadableDatabase();
+        Cursor c = null;
+        try {
+            c = query(db, TABLE_SETTINGS, new String[] {"packageName"}, null, null, null, null, null, null);
+//            Log.d(TAG, "purgeSettings - found " + c.getCount() + " entries in the DB");
+            List<String> appsInDb = new ArrayList<String>();
+            while (c.moveToNext()) {
+                String packageName = c.getString(0);
+                if (!apps.contains(packageName)) {
+                    deleteSettings(packageName);
+                } else {
+                    if (appsInDb.contains(packageName)) { // if duplicate entry, remove all duplicates and keep only one
+                        PrivacySettings pSetTmp = getSettings(packageName, false);
+                        deleteSettings(packageName);
+                        saveSettings(pSetTmp);
+                    } else {
+                        appsInDb.add(packageName);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "purgeSettings - purging DB failed", e);
+            result = false;
+        } finally {
+            if (c != null) c.close();
+            synchronized (readingThreads) {
+                readingThreads--;
+                // only close DB if no other threads are reading
+                if (readingThreads == 0 && db != null && db.isOpen()) {
+                    db.close();
+                }
+            }
+        }
+        return result;
+    }
+    
+    private void deleteRecursive(File fileOrDirectory) {
+        if (fileOrDirectory.isDirectory()) {
+            for (File child : fileOrDirectory.listFiles()) deleteRecursive(child);
+        }
+        fileOrDirectory.delete();
+    }
+    
+    private synchronized void createDatabase() {
+        Log.i(TAG, "createDatabase - creating privacy database file");
+        try {
+            SQLiteDatabase db = 
+                SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READWRITE | 
+                        SQLiteDatabase.CREATE_IF_NECESSARY);
+            Log.i(TAG, "createDatabase - creating privacy database");
+            db.execSQL(CREATE_TABLE_SETTINGS);
+            db.execSQL(CREATE_TABLE_ALLOWED_CONTACTS);
+            db.execSQL(CREATE_TABLE_MAP);
+            db.execSQL(INSERT_VERSION);
+            db.execSQL(INSERT_ENABLED);
+            db.execSQL(INSERT_NOTIFICATIONS_ENABLED);
+    //        Log.d(TAG, "createDatabase - closing connection to privacy.db");
+            if (db != null && db.isOpen()) db.close();
+        } catch (SQLException e) {
+            Log.e(TAG, "createDatabase - failed to create privacy database", e);
+        }
+    }
+    
+    private synchronized void createSettingsDir() {
+        // create settings directory (for settings accessed from core libraries)
+        File settingsDir = new File("/data/system/privacy/");
+        settingsDir.mkdirs();
+        // make it readable for everybody
+        settingsDir.setReadable(true, false);
+        settingsDir.setExecutable(true, false);
+    }
+    
+    private synchronized SQLiteDatabase getReadableDatabase() {
+        if (db != null && db.isOpen()) return db;
+        
+        db = SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READONLY);
+        
+        return db;
+    }
+
+    private synchronized SQLiteDatabase getWritableDatabase() {
+        // create the database if it does not exist
+        if (!new File(DATABASE_FILE).exists()) createDatabase();
+        
+        if (db != null && db.isOpen() && !db.isReadOnly()) return db;
+        
+        db = SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READWRITE);
+
+        return db;
+    }
+}
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl b/frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl
--- a/frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl	2012-08-10 03:30:54.980902750 +0000
@@ -0,0 +1,4 @@
+package android.privacy;
+
+/** {@hide} */
+parcelable PrivacySettings;
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/PrivacySettings.java b/frameworks/base/privacy/java/android/privacy/PrivacySettings.java
--- a/frameworks/base/privacy/java/android/privacy/PrivacySettings.java	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/PrivacySettings.java	2012-08-10 03:30:54.984903393 +0000
@@ -0,0 +1,665 @@
+package android.privacy;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+
+import java.math.BigDecimal;
+import java.util.List;
+import java.util.Random;
+
+/**
+ * Holds privacy settings for access to all private data types for a single application
+ * @author Svyatoslav Hresyk 
+ * {@hide} 
+ */
+public final class PrivacySettings implements Parcelable {
+    
+    /**
+     * Real value, provided by the unmodified Android framework.
+     */
+    public static final byte REAL = 0;
+    
+    /**
+     * Empty or unavailable, depending on setting type. For String settings, it is
+     * setter method caller's responsibility to make sure that the corresponding 
+     * setting field will contain an empty String.
+     */
+    public static final byte EMPTY = 1;
+    
+    /**
+     * Custom specified output, appropriate for relevant setting. For String settings, 
+     * it is setter method caller's responsibility to make sure that the corresponding 
+     * setting field will contain a custom String.
+     */
+    public static final byte CUSTOM = 2;
+    
+    /**
+     * Random output, appropriate for relevant setting. When this option is set, the
+     * corresponding getter methods will generate appropriate random values automatically.
+     * 
+     * Device ID: a random string consisting of 15 numeric digits preceded by a "+"
+     * Line1Number: a random string consisting of 13 numeric digits
+     */
+    public static final byte RANDOM = 3;
+    
+    public static final byte SETTING_NOTIFY_OFF = 0;
+    public static final byte SETTING_NOTIFY_ON = 1;
+    
+    // constants for identification of data types transmitted in the notification intent
+    public static final String DATA_DEVICE_ID = "deviceID";
+    public static final String DATA_LINE_1_NUMBER = "line1Number";
+    public static final String DATA_LOCATION_GPS = "locationGPS";
+    public static final String DATA_LOCATION_NETWORK = "locationNetwork";
+    public static final String DATA_NETWORK_INFO_CURRENT = "networkInfoCurrent";
+    public static final String DATA_NETWORK_INFO_SIM = "networkInfoSIM";
+    public static final String DATA_SIM_SERIAL = "simSerial";
+    public static final String DATA_SUBSCRIBER_ID = "subscriberID";
+    public static final String DATA_ACCOUNTS_LIST = "accountsList";
+    public static final String DATA_AUTH_TOKENS = "authTokens";
+    public static final String DATA_OUTGOING_CALL = "outgoingCall";
+    public static final String DATA_INCOMING_CALL = "incomingCall";
+    public static final String DATA_CONTACTS = "contacts";
+    public static final String DATA_CALENDAR = "calendar";
+    public static final String DATA_MMS = "mms";
+    public static final String DATA_SMS = "sms";
+    public static final String DATA_MMS_SMS = "mmsSms";
+    public static final String DATA_CALL_LOG = "callLog";
+    public static final String DATA_BOOKMARKS = "bookmarks";
+    public static final String DATA_SYSTEM_LOGS = "systemLogs";
+    public static final String DATA_INTENT_BOOT_COMPLETED = "intentBootCompleted";
+//    public static final String DATA_EXTERNAL_STORAGE = "externalStorage";
+//    public static final String DATA_CAMERA = "camera";
+//    public static final String DATA_RECORD_AUDIO = "recordAudio";
+    
+    // Database entry ID
+    private final Integer _id;
+    
+    // Application identifiers
+    private String packageName;
+    private int uid;
+    
+    //
+    // Privacy settings
+    //
+    
+    private byte deviceIdSetting;
+    private String deviceId;
+    
+    // Phone and Voice Mailbox Number
+    private byte line1NumberSetting; 
+    private String line1Number;
+    
+    private byte locationGpsSetting;
+    private String locationGpsLat;
+    private String locationGpsLon;
+    private byte locationNetworkSetting;
+    private String locationNetworkLat;
+    private String locationNetworkLon;
+    
+    // CountryIso, Operator Code, Operator Name
+    private byte networkInfoSetting;
+    private byte simInfoSetting;
+    
+    private byte simSerialNumberSetting;
+    private String simSerialNumber;
+    private byte subscriberIdSetting;
+    private String subscriberId;
+    
+    private byte accountsSetting;
+    private byte accountsAuthTokensSetting;
+    private byte outgoingCallsSetting;
+    private byte incomingCallsSetting;
+    
+    private byte contactsSetting;
+    private byte calendarSetting;
+    private byte mmsSetting;
+    private byte smsSetting;
+    private byte callLogSetting;
+    private byte bookmarksSetting; // browser bookmarks and history
+    
+    private byte systemLogsSetting;
+    
+    private byte notificationSetting;
+    
+    private byte intentBootCompletedSetting;
+//    private byte externalStorageSetting;
+//    private byte cameraSetting;
+//    private byte recordAudioSetting;
+    
+    private int[] allowedContacts;
+
+    public PrivacySettings(Integer _id, String packageName, int uid) {
+        this._id = _id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        
+        this.deviceIdSetting = REAL;
+        this.deviceId = null;
+        this.line1NumberSetting = REAL;
+        this.line1Number = null;
+        this.locationGpsSetting = REAL;
+        this.locationGpsLat = null;
+        this.locationGpsLon = null;
+        this.locationNetworkSetting = REAL;
+        this.locationNetworkLat = null;
+        this.locationNetworkLon = null;
+        this.networkInfoSetting = REAL;
+        this.simInfoSetting = REAL;
+        this.simSerialNumberSetting = REAL;
+        this.simSerialNumber = null;
+        this.subscriberIdSetting = REAL;
+        this.subscriberId = null;
+        this.accountsSetting = REAL;
+        this.accountsAuthTokensSetting = REAL;
+        this.outgoingCallsSetting = REAL;
+        this.incomingCallsSetting = REAL;
+        this.contactsSetting = REAL;
+        this.calendarSetting = REAL;
+        this.mmsSetting = REAL;
+        this.smsSetting = REAL;
+        this.callLogSetting = REAL;
+        this.bookmarksSetting = REAL;
+        this.systemLogsSetting = REAL;
+        this.notificationSetting = SETTING_NOTIFY_OFF;
+        this.intentBootCompletedSetting = REAL;
+//        this.externalStorageSetting = REAL;
+//        this.cameraSetting = REAL;
+//        this.recordAudioSetting = REAL;
+        this.allowedContacts = null;
+    }
+    
+    public PrivacySettings(Integer id, String packageName, int uid, byte deviceIdSetting, String deviceId,
+            byte line1NumberSetting, String line1Number, byte locationGpsSetting, String locationGpsLat,
+            String locationGpsLon, byte locationNetworkSetting, String locationNetworkLat, 
+            String locationNetworkLon, byte networkInfoSetting, byte simInfoSetting, byte simSerialNumberSetting,
+            String simSerialNumber, byte subscriberIdSetting, String subscriberId, byte accountsSetting, 
+            byte accountsAuthTokensSetting, byte outgoingCallsSetting, byte incomingCallsSetting, byte contactsSetting,
+            byte calendarSetting, byte mmsSetting, byte smsSetting, byte callLogSetting, byte bookmarksSetting, 
+            byte systemLogsSetting, byte externalStorageSetting, byte cameraSetting, byte recordAudioSetting, 
+            byte notificationSetting, byte intentBootCompletedSetting, int[] allowedContacts) {
+        this._id = id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        
+        this.deviceIdSetting = deviceIdSetting;
+        this.deviceId = deviceId;
+        this.line1NumberSetting = line1NumberSetting;
+        this.line1Number = line1Number;
+        this.locationGpsSetting = locationGpsSetting;
+        this.locationGpsLat = locationGpsLat;
+        this.locationGpsLon = locationGpsLon;
+        this.locationNetworkSetting = locationNetworkSetting;
+        this.locationNetworkLat = locationNetworkLat;
+        this.locationNetworkLon = locationNetworkLon;
+        this.networkInfoSetting = networkInfoSetting;
+        this.simInfoSetting = simInfoSetting;
+        this.simSerialNumberSetting = simSerialNumberSetting;
+        this.simSerialNumber = simSerialNumber;
+        this.subscriberIdSetting = subscriberIdSetting;
+        this.subscriberId = subscriberId;
+        this.accountsSetting = accountsSetting;
+        this.accountsAuthTokensSetting = accountsAuthTokensSetting;
+        this.outgoingCallsSetting = outgoingCallsSetting;
+        this.incomingCallsSetting = incomingCallsSetting;
+        this.contactsSetting = contactsSetting;
+        this.calendarSetting = calendarSetting;
+        this.mmsSetting = mmsSetting;
+        this.smsSetting = smsSetting;
+        this.callLogSetting = callLogSetting;
+        this.bookmarksSetting = bookmarksSetting;
+        this.systemLogsSetting = systemLogsSetting;
+        this.notificationSetting = notificationSetting;
+        this.intentBootCompletedSetting = intentBootCompletedSetting;
+//        this.externalStorageSetting = externalStorageSetting;
+//        this.cameraSetting = cameraSetting;
+//        this.recordAudioSetting = recordAudioSetting;
+        this.allowedContacts = allowedContacts;
+    }
+
+    public Integer get_id() {
+        return _id;
+    }
+
+    public String getPackageName() {
+        return packageName;
+    }
+    
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+    
+    public int getUid() {
+        return uid;
+    }
+
+    public void setUid(int uid) {
+        this.uid = uid;
+    }
+
+    public byte getDeviceIdSetting() {
+        return deviceIdSetting;
+    }
+
+    public void setDeviceIdSetting(byte deviceIdSetting) {
+        this.deviceIdSetting = deviceIdSetting;
+    }
+
+    public String getDeviceId() {
+        if (deviceIdSetting == EMPTY) return "";
+        if (deviceIdSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = Math.abs(rnd.nextLong()) + "";
+            return rndId.substring(0, 15);
+        }
+        return deviceId;
+    }
+
+    public void setDeviceId(String deviceId) {
+        this.deviceId = deviceId;
+    }
+
+    public byte getLine1NumberSetting() {
+        return line1NumberSetting;
+    }
+
+    public void setLine1NumberSetting(byte line1NumberSetting) {
+        this.line1NumberSetting = line1NumberSetting;
+    }
+
+    public String getLine1Number() {
+        if (line1NumberSetting == EMPTY) return "";
+        if (line1NumberSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = "+" + Math.abs(rnd.nextLong()) + "";
+            return rndId.substring(0, 13);
+        }
+        return line1Number;
+    }
+
+    public void setLine1Number(String line1Number) {
+        this.line1Number = line1Number;
+    }
+
+    public byte getLocationGpsSetting() {
+        return locationGpsSetting;
+    }
+
+    public void setLocationGpsSetting(byte locationGpsSetting) {
+        this.locationGpsSetting = locationGpsSetting;
+    }
+    
+    public String getLocationGpsLat() {
+        if (locationGpsSetting == EMPTY) return "";
+        if (locationGpsSetting == RANDOM) return getRandomLat();
+        return locationGpsLat;
+    }
+
+    public void setLocationGpsLat(String locationGpsLat) {
+        this.locationGpsLat = locationGpsLat;
+    }
+
+    public String getLocationGpsLon() {
+        if (locationGpsSetting == EMPTY) return "";        
+        if (locationGpsSetting == RANDOM) return getRandomLon();
+        return locationGpsLon;
+    }
+
+    public void setLocationGpsLon(String locationGpsLon) {
+        this.locationGpsLon = locationGpsLon;
+    }
+
+    public byte getLocationNetworkSetting() {
+        return locationNetworkSetting;
+    }
+
+    public void setLocationNetworkSetting(byte locationNetworkSetting) {
+        this.locationNetworkSetting = locationNetworkSetting;
+    }
+
+    public String getLocationNetworkLat() {
+        if (locationNetworkSetting == EMPTY) return "";
+        if (locationNetworkSetting == RANDOM) return getRandomLat();  
+        return locationNetworkLat;
+    }
+
+    public void setLocationNetworkLat(String locationNetworkLat) {
+        this.locationNetworkLat = locationNetworkLat;
+    }
+
+    public String getLocationNetworkLon() {
+        if (locationNetworkSetting == EMPTY) return "";
+        if (locationNetworkSetting == RANDOM) return getRandomLon();
+        return locationNetworkLon;
+    }
+
+    public void setLocationNetworkLon(String locationNetworkLon) {
+        this.locationNetworkLon = locationNetworkLon;
+    }
+
+    public byte getNetworkInfoSetting() {
+        return networkInfoSetting;
+    }
+
+    public void setNetworkInfoSetting(byte networkInfoSetting) {
+        this.networkInfoSetting = networkInfoSetting;
+    }
+
+    public byte getSimInfoSetting() {
+        return simInfoSetting;
+    }
+
+    public void setSimInfoSetting(byte simInfoSetting) {
+        this.simInfoSetting = simInfoSetting;
+    }
+
+    public byte getSimSerialNumberSetting() {
+        return simSerialNumberSetting;
+    }
+
+    public void setSimSerialNumberSetting(byte simSerialNumberSetting) {
+        this.simSerialNumberSetting = simSerialNumberSetting;
+    }
+
+    public String getSimSerialNumber() {
+        if (simSerialNumberSetting == EMPTY) return "";
+        if (simSerialNumberSetting == RANDOM) {
+            Random rnd = new Random();
+            return Math.abs(rnd.nextLong()) + "";
+        }
+        return simSerialNumber;
+    }
+
+    public void setSimSerialNumber(String simSerialNumber) {
+        this.simSerialNumber = simSerialNumber;
+    }
+
+    public byte getSubscriberIdSetting() {
+        return subscriberIdSetting;
+    }
+
+    public void setSubscriberIdSetting(byte subscriberIdSetting) {
+        this.subscriberIdSetting = subscriberIdSetting;
+    }
+
+    public String getSubscriberId() {
+        if (subscriberIdSetting == EMPTY) return "";
+        if (subscriberIdSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = Math.abs(rnd.nextLong()) + "";
+            return rndId.substring(0, 15);
+        }
+        return subscriberId;
+    }
+
+    public void setSubscriberId(String subscriberId) {
+        this.subscriberId = subscriberId;
+    }
+
+    public byte getAccountsSetting() {
+        return accountsSetting;
+    }
+
+    public void setAccountsSetting(byte accountsSetting) {
+        this.accountsSetting = accountsSetting;
+    }
+
+    public byte getAccountsAuthTokensSetting() {
+        return accountsAuthTokensSetting;
+    }
+
+    public void setAccountsAuthTokensSetting(byte accountsAuthTokensSetting) {
+        this.accountsAuthTokensSetting = accountsAuthTokensSetting;
+    }
+
+    public byte getOutgoingCallsSetting() {
+        return outgoingCallsSetting;
+    }
+
+    public void setOutgoingCallsSetting(byte outgoingCallsSetting) {
+        this.outgoingCallsSetting = outgoingCallsSetting;
+    }
+    
+    public byte getIncomingCallsSetting() {
+        return incomingCallsSetting;
+    }
+    
+    public void setIncomingCallsSetting(byte incomingCallsSetting) {
+        this.incomingCallsSetting = incomingCallsSetting;
+    }
+
+    public byte getContactsSetting() {
+        return contactsSetting;
+    }
+
+    public void setContactsSetting(byte contactsSetting) {
+        this.contactsSetting = contactsSetting;
+    }
+
+    public byte getCalendarSetting() {
+        return calendarSetting;
+    }
+
+    public void setCalendarSetting(byte calendarSetting) {
+        this.calendarSetting = calendarSetting;
+    }
+
+    public byte getMmsSetting() {
+        return mmsSetting;
+    }
+
+    public void setMmsSetting(byte mmsSetting) {
+        this.mmsSetting = mmsSetting;
+    }
+
+    public byte getSmsSetting() {
+        return smsSetting;
+    }
+
+    public void setSmsSetting(byte smsSetting) {
+        this.smsSetting = smsSetting;
+    }
+
+    public byte getCallLogSetting() {
+        return callLogSetting;
+    }
+
+    public void setCallLogSetting(byte callLogSetting) {
+        this.callLogSetting = callLogSetting;
+    }
+
+    public byte getBookmarksSetting() {
+        return bookmarksSetting;
+    }
+
+    public void setBookmarksSetting(byte bookmarksSetting) {
+        this.bookmarksSetting = bookmarksSetting;
+    }
+
+    public byte getSystemLogsSetting() {
+        return systemLogsSetting;
+    }
+
+    public void setSystemLogsSetting(byte systemLogsSetting) {
+        this.systemLogsSetting = systemLogsSetting;
+    }
+
+    public byte getIntentBootCompletedSetting() {
+        return intentBootCompletedSetting;
+    }
+
+    public void setIntentBootCompletedSetting(byte intentBootCompletedSetting) {
+        this.intentBootCompletedSetting = intentBootCompletedSetting;
+    }
+
+    public byte getNotificationSetting() {
+        return notificationSetting;
+    }
+
+    public void setNotificationSetting(byte notificationSetting) {
+        this.notificationSetting = notificationSetting;
+    }
+    
+    public int[] getAllowedContacts() {
+        return allowedContacts;
+    }
+
+    public void setAllowedContacts(int[] allowedContacts) {
+        this.allowedContacts = allowedContacts;
+    }
+
+    @Override
+    public String toString() {
+        return "PrivacySettings [_id=" + _id + ", accountsAuthTokensSetting=" + accountsAuthTokensSetting
+                + ", accountsSetting=" + accountsSetting + ", bookmarksSetting=" + bookmarksSetting
+                + ", calendarSetting=" + calendarSetting + ", callLogSetting=" + callLogSetting + ", contactsSetting="
+                + contactsSetting + ", deviceId=" + deviceId + ", deviceIdSetting=" + deviceIdSetting
+                + ", incomingCallsSetting=" + incomingCallsSetting + ", intentBootCompletedSetting="
+                + intentBootCompletedSetting + ", line1Number=" + line1Number + ", line1NumberSetting="
+                + line1NumberSetting + ", locationGpsLat=" + locationGpsLat + ", locationGpsLon=" + locationGpsLon
+                + ", locationGpsSetting=" + locationGpsSetting + ", locationNetworkLat=" + locationNetworkLat
+                + ", locationNetworkLon=" + locationNetworkLon + ", locationNetworkSetting=" + locationNetworkSetting
+                + ", mmsSetting=" + mmsSetting + ", networkInfoSetting=" + networkInfoSetting
+                + ", notificationSetting=" + notificationSetting + ", outgoingCallsSetting=" + outgoingCallsSetting
+                + ", packageName=" + packageName + ", simInfoSetting=" + simInfoSetting + ", simSerialNumber="
+                + simSerialNumber + ", simSerialNumberSetting=" + simSerialNumberSetting + ", smsSetting=" + smsSetting
+                + ", subscriberId=" + subscriberId + ", subscriberIdSetting=" + subscriberIdSetting
+                + ", systemLogsSetting=" + systemLogsSetting + ", uid=" + uid + "]";
+    }
+
+    /**
+     * Util methods
+     */
+    
+    private String getRandomLat() {
+        BigDecimal latitude;
+        double lat = Math.random() * 180;
+        if (lat > 90) latitude = new BigDecimal(lat - 90);
+        else latitude = new BigDecimal(-lat);
+        return latitude.setScale(6, BigDecimal.ROUND_HALF_UP) + "";
+    }
+    
+    private String getRandomLon() {
+        BigDecimal longitude;
+        double lon = Math.random() * 360;
+        if (lon > 180) longitude = new BigDecimal(lon - 180);
+        else longitude = new BigDecimal(-lon);
+        return longitude.setScale(6, BigDecimal.ROUND_HALF_UP) + "";
+    }
+
+    /**
+     * Parcelable implementation
+     */
+
+    public static final Parcelable.Creator<PrivacySettings> CREATOR = new
+            Parcelable.Creator<PrivacySettings>() {
+                public PrivacySettings createFromParcel(Parcel in) {
+                    return new PrivacySettings(in);
+                }
+
+                public PrivacySettings[] newArray(int size) {
+                    return new PrivacySettings[size];
+                }
+            };
+    
+    public PrivacySettings(Parcel in) {
+        int _id = in.readInt();
+        this._id = (_id == -1) ? null : _id;
+        
+        this.packageName = in.readString();
+        this.uid = in.readInt();
+        
+        this.deviceIdSetting = in.readByte();
+        this.deviceId = in.readString();
+        this.line1NumberSetting = in.readByte();
+        this.line1Number = in.readString();
+        this.locationGpsSetting = in.readByte();
+        this.locationGpsLat = in.readString();
+        this.locationGpsLon = in.readString();
+        this.locationNetworkSetting = in.readByte();
+        this.locationNetworkLat = in.readString();
+        this.locationNetworkLon = in.readString();
+        this.networkInfoSetting = in.readByte();
+        this.simInfoSetting = in.readByte();
+        this.simSerialNumberSetting = in.readByte();
+        this.simSerialNumber = in.readString();
+        this.subscriberIdSetting = in.readByte();
+        this.subscriberId = in.readString();
+        this.accountsSetting = in.readByte();
+        this.accountsAuthTokensSetting = in.readByte();
+        this.outgoingCallsSetting = in.readByte();
+        this.incomingCallsSetting = in.readByte();
+        this.contactsSetting = in.readByte();
+        this.calendarSetting = in.readByte();
+        this.mmsSetting = in.readByte();
+        this.smsSetting = in.readByte();
+        this.callLogSetting = in.readByte();
+        this.bookmarksSetting = in.readByte();
+        this.systemLogsSetting = in.readByte();
+        this.notificationSetting = in.readByte();
+        this.intentBootCompletedSetting = in.readByte();
+//        this.externalStorageSetting = in.readByte();
+//        this.cameraSetting = in.readByte();
+//        this.recordAudioSetting = in.readByte();
+//        int[] buffer = in.createIntArray();
+//        if (buffer != null && buffer.length > 0) {
+//            in.readIntArray(buffer);
+//            int count = 0;
+//            for (int i = 0; i < buffer.length; i++) if (buffer[i] != 0) count++; else break;
+//            this.allowedContacts = new int[count];
+//            System.arraycopy(buffer, 0, allowedContacts, 0, count);
+//        } // else it will be null
+        
+        this.allowedContacts = in.createIntArray();
+    }
+    
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt((_id == null) ? -1 : _id);
+        
+        dest.writeString(packageName);
+        dest.writeInt(uid);
+        
+        dest.writeByte(deviceIdSetting);
+        dest.writeString(deviceId);
+        dest.writeByte(line1NumberSetting);
+        dest.writeString(line1Number);
+        dest.writeByte(locationGpsSetting);
+        dest.writeString(locationGpsLat);
+        dest.writeString(locationGpsLon);
+        dest.writeByte(locationNetworkSetting);
+        dest.writeString(locationNetworkLat);
+        dest.writeString(locationNetworkLon);
+        dest.writeByte(networkInfoSetting);
+        dest.writeByte(simInfoSetting);
+        dest.writeByte(simSerialNumberSetting);
+        dest.writeString(simSerialNumber);
+        dest.writeByte(subscriberIdSetting);
+        dest.writeString(subscriberId);
+        dest.writeByte(accountsSetting);
+        dest.writeByte(accountsAuthTokensSetting);
+        dest.writeByte(outgoingCallsSetting);
+        dest.writeByte(incomingCallsSetting);
+        dest.writeByte(contactsSetting);
+        dest.writeByte(calendarSetting);
+        dest.writeByte(mmsSetting);
+        dest.writeByte(smsSetting);
+        dest.writeByte(callLogSetting);
+        dest.writeByte(bookmarksSetting);
+        dest.writeByte(systemLogsSetting);
+        dest.writeByte(notificationSetting);
+        dest.writeByte(intentBootCompletedSetting);
+//        dest.writeByte(externalStorageSetting);
+//        dest.writeByte(cameraSetting);
+//        dest.writeByte(recordAudioSetting);
+        dest.writeIntArray(allowedContacts);
+    }
+    
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+    
+}
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/PrivacySettingsManager.java b/frameworks/base/privacy/java/android/privacy/PrivacySettingsManager.java
--- a/frameworks/base/privacy/java/android/privacy/PrivacySettingsManager.java	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/PrivacySettingsManager.java	2012-08-10 03:30:54.984903393 +0000
@@ -0,0 +1,198 @@
+package android.privacy;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.util.Log;
+
+/**
+ * Provides API access to the privacy settings
+ * @author Svyatoslav Hresyk
+ * TODO: selective contacts access
+ * {@hide}
+ */
+public class PrivacySettingsManager {
+
+    private static final String TAG = "PrivacySettingsManager";
+    
+    public static final String ACTION_PRIVACY_NOTIFICATION = "com.privacy.pdroid.PRIVACY_NOTIFICATION";
+    
+    private IPrivacySettingsManager service;
+    
+    /**
+     * @hide - this should be instantiated through Context.getSystemService
+     * @param context
+     */
+    public PrivacySettingsManager(Context context, IPrivacySettingsManager service) {
+//        Log.d(TAG, "PrivacySettingsManager - initializing for package: " + context.getPackageName() + 
+//                " UID:" + Binder.getCallingUid());
+        this.service = service;
+    }
+
+    public PrivacySettings getSettings(String packageName, int uid) {
+        return getSettings(packageName);
+    }
+    
+    public PrivacySettings getSettings(String packageName) {
+        try {
+//            Log.d(TAG, "getSettings for package: " + packageName + " UID: " + uid);
+            if (service != null) {
+                return service.getSettings(packageName);
+            } else {
+                Log.e(TAG, "getSettings - PrivacySettingsManagerService is null");
+                return null;
+            }
+        } catch (RemoteException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    public boolean saveSettings(PrivacySettings settings) {
+        try {
+//            Log.d(TAG, "saveSettings - " + settings);
+            if (service != null) {            
+                return service.saveSettings(settings);
+            } else {
+                Log.e(TAG, "saveSettings - PrivacySettingsManagerService is null");
+                return false;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in saveSettings: ", e);
+            return false;
+        }
+    }
+    
+    public boolean deleteSettings(String packageName) {
+        return deleteSettings(packageName);
+    }
+    
+    public boolean deleteSettings(String packageName, int uid) {
+        try {
+//            Log.d(TAG, "deleteSettings - "  + packageName + " UID: " + uid);
+            if (service != null) {
+                return service.deleteSettings(packageName);
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+                return false;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in deleteSettings: ", e);
+            return false;
+        }
+    }
+    
+    /**
+     * Checks whether the PrivacySettingsManagerService is available. For some reason,
+     * occasionally it appears to be null. In this case it should be initialized again.
+     */
+    public boolean isServiceAvailable() {
+        if (service != null) return true;
+        return false;
+    }
+    
+    public void notification(String packageName, int uid, byte accessMode, String dataType, String output, PrivacySettings pSet) {
+        notification(packageName, accessMode, dataType, output, pSet);
+    }
+    
+    public void notification(String packageName, byte accessMode, String dataType, String output, PrivacySettings pSet) {
+//        if (pSet != null && pSet.getNotificationSetting() == PrivacySettings.SETTING_NOTIFY_ON) {
+            try {
+                if (service != null) {
+                    service.notification(packageName, accessMode, dataType, output);
+                } else {
+                    Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+                }            
+            } catch (RemoteException e) {
+                Log.e(TAG, "RemoteException in notification: ", e);
+            }
+//        }
+    }
+    
+    public void registerObservers() {
+        try {
+            if (service != null) {
+                service.registerObservers();
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in registerObservers: ", e);
+        }
+    }
+    
+    public void addObserver(String packageName) {
+        try {
+            if (service != null) {
+                service.addObserver(packageName);
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in addObserver: ", e);
+        }
+    }
+    
+    public boolean purgeSettings() {
+        try {
+            if (service != null) {
+                return service.purgeSettings();
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in purgeSettings: ", e);
+        }
+        return false;
+    }
+    
+    public double getVersion() {
+        try {
+            if (service != null) {
+                return service.getVersion();
+            } else {
+                Log.e(TAG, "getVersion - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in getVersion: ", e);
+        }
+        return 0;
+    }
+    
+    public boolean setEnabled(boolean enable) {
+        try {
+            if (service != null) {
+                return service.setEnabled(enable);
+            } else {
+                Log.e(TAG, "setEnabled - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setEnabled: ", e);
+        }
+        return false;
+    }
+    
+    public boolean setNotificationsEnabled(boolean enable) {
+        try {
+            if (service != null) {
+                return service.setNotificationsEnabled(enable);
+            } else {
+                Log.e(TAG, "setNotificationsEnabled - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setNotificationsEnabled: ", e);
+        }
+        return false;
+    }
+    
+    public void setBootCompleted() {
+        try {
+            if (service != null) {
+                service.setBootCompleted();
+            } else {
+                Log.e(TAG, "setBootCompleted - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setBootCompleted: ", e);
+        }
+    }
+}
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/PrivacySettingsManagerService.java b/frameworks/base/privacy/java/android/privacy/PrivacySettingsManagerService.java
--- a/frameworks/base/privacy/java/android/privacy/PrivacySettingsManagerService.java	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/PrivacySettingsManagerService.java	2012-08-10 03:30:54.988904025 +0000
@@ -0,0 +1,142 @@
+package android.privacy;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Binder;
+import android.util.Log;
+
+import java.io.File;
+
+/**
+ * PrivacySettingsManager's counterpart running in the system process, which
+ * allows write access to /data/
+ * @author Svyatoslav Hresyk
+ * TODO: add selective contact access management API
+ * {@hide}
+ */
+public class PrivacySettingsManagerService extends IPrivacySettingsManager.Stub {
+
+    private static final String TAG = "PrivacySettingsManagerService";
+    
+    private static final String WRITE_PRIVACY_SETTINGS = "android.privacy.WRITE_PRIVACY_SETTINGS";
+
+    private PrivacyPersistenceAdapter persistenceAdapter;
+
+    private Context context;
+    
+    public static PrivacyFileObserver obs;
+    
+    private boolean enabled;
+    private boolean notificationsEnabled;
+    private boolean bootCompleted;
+    
+    private static final double VERSION = 1.32;
+    
+    /**
+     * @hide - this should be instantiated through Context.getSystemService
+     * @param context
+     */
+    public PrivacySettingsManagerService(Context context) {
+        Log.i(TAG, "PrivacySettingsManagerService - initializing for package: " + context.getPackageName() + 
+                " UID: " + Binder.getCallingUid());
+        this.context = context;
+        
+        persistenceAdapter = new PrivacyPersistenceAdapter(context);
+        obs = new PrivacyFileObserver("/data/system/privacy", this);
+        
+        enabled = persistenceAdapter.getValue(PrivacyPersistenceAdapter.SETTING_ENABLED).equals(PrivacyPersistenceAdapter.VALUE_TRUE);
+        notificationsEnabled = persistenceAdapter.getValue(PrivacyPersistenceAdapter.SETTING_NOTIFICATIONS_ENABLED).equals(PrivacyPersistenceAdapter.VALUE_TRUE);
+        bootCompleted = false;
+    }
+    
+    public PrivacySettings getSettings(String packageName) {
+//        Log.d(TAG, "getSettings - " + packageName);
+        if (enabled || context.getPackageName().equals("com.privacy.pdroid")) 
+            return persistenceAdapter.getSettings(packageName, false);
+        else return null;
+    }
+
+    public boolean saveSettings(PrivacySettings settings) {
+        Log.d(TAG, "saveSettings - checking if caller (UID: " + Binder.getCallingUid() + ") has sufficient permissions");
+        // check permission if not being called by the system process
+        if (Binder.getCallingUid() != 1000) 
+            context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");
+        Log.d(TAG, "saveSettings - " + settings);
+        boolean result = persistenceAdapter.saveSettings(settings);
+        if (result == true) obs.addObserver(settings.getPackageName());
+        return result;
+    }
+    
+    public boolean deleteSettings(String packageName) {
+//        Log.d(TAG, "deleteSettings - " + packageName + " UID: " + uid + " " +
+//        		"checking if caller (UID: " + Binder.getCallingUid() + ") has sufficient permissions");
+        // check permission if not being called by the system process
+        if (Binder.getCallingUid() != 1000)
+            context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");
+        boolean result = persistenceAdapter.deleteSettings(packageName);
+        // update observer if directory exists
+        String observePath = PrivacyPersistenceAdapter.SETTINGS_DIRECTORY + "/" + packageName;
+        if (new File(observePath).exists() && result == true) {
+            obs.addObserver(observePath);
+        } else if (result == true) {
+            obs.children.remove(observePath);
+        }
+        return result;
+    }
+    
+    public double getVersion() {
+        return VERSION;
+    }
+    
+    public void notification(final String packageName, final byte accessMode, final String dataType, final String output) {
+        if (bootCompleted && notificationsEnabled) {
+            Intent intent = new Intent();
+            intent.setAction(PrivacySettingsManager.ACTION_PRIVACY_NOTIFICATION);
+            intent.putExtra("packageName", packageName);
+            intent.putExtra("uid", PrivacyPersistenceAdapter.DUMMY_UID);
+            intent.putExtra("accessMode", accessMode);
+            intent.putExtra("dataType", dataType);
+            intent.putExtra("output", output);
+            context.sendBroadcast(intent);
+        }
+    }
+    
+    public void registerObservers() {
+        context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");        
+        obs = new PrivacyFileObserver("/data/system/privacy", this);
+    }
+    
+    public void addObserver(String packageName) {
+        context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");        
+        obs.addObserver(packageName);
+    }
+    
+    public boolean purgeSettings() {
+        return persistenceAdapter.purgeSettings();
+    }
+    
+    public void setBootCompleted() {
+        bootCompleted = true;
+    }
+    
+    public boolean setNotificationsEnabled(boolean enable) {
+        String value = enable ? PrivacyPersistenceAdapter.VALUE_TRUE : PrivacyPersistenceAdapter.VALUE_FALSE;
+        if (persistenceAdapter.setValue(PrivacyPersistenceAdapter.SETTING_NOTIFICATIONS_ENABLED, value)) {
+            this.notificationsEnabled = true;
+            this.bootCompleted = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+    
+    public boolean setEnabled(boolean enable) {
+        String value = enable ? PrivacyPersistenceAdapter.VALUE_TRUE : PrivacyPersistenceAdapter.VALUE_FALSE;
+        if (persistenceAdapter.setValue(PrivacyPersistenceAdapter.SETTING_ENABLED, value)) {
+            this.enabled = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java b/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java
--- a/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java	2012-08-10 03:30:54.988904025 +0000
@@ -0,0 +1,285 @@
+package android.privacy.surrogate;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AccountManagerCallback;
+import android.accounts.AccountManagerFuture;
+import android.accounts.AuthenticatorException;
+import android.accounts.IAccountManager;
+import android.accounts.OperationCanceledException;
+import android.app.Activity;
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Provides privacy handling for {@link android.accounts.AccountManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyAccountManager extends AccountManager {
+    
+    private static final String TAG = "PrivacyAccountManager";
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+
+    /** {@hide} */
+    public PrivacyAccountManager(Context context, IAccountManager service) {
+        super(context, service);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));  
+    }
+
+    /** {@hide} */
+    public PrivacyAccountManager(Context context, IAccountManager service, Handler handler) {
+        super(context, service, handler);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));        
+    }
+
+    /**
+     * GET_ACCOUNTS
+     */
+    
+    @Override
+    public Account[] getAccounts() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        Account[] output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[empty accounts list]";
+            output = new Account[0];
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccounts(); 
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+        
+//        Log.d(TAG, "getAccounts - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+
+    @Override
+    public Account[] getAccountsByType(String type) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        Account[] output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[empty accounts list]";
+            output = new Account[0];
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccountsByType(type);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+        
+//        Log.d(TAG, "getAccountsByType - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+    
+    @Override
+    public AccountManagerFuture<Boolean> hasFeatures(Account account, String[] features,
+            AccountManagerCallback<Boolean> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);        
+        String output_label;
+        AccountManagerFuture<Boolean> output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[false]";
+            output = new PrivacyAccountManagerFuture<Boolean>(false);
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.hasFeatures(account, features, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);            
+        }
+        
+//        Log.d(TAG, "hasFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String type, String[] features,
+            AccountManagerCallback<Account[]> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);       
+        String output_label;
+        AccountManagerFuture<Account[]> output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[false]";
+            output = new PrivacyAccountManagerFuture<Account[]>(new Account[0]);
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAccountsByTypeAndFeatures(type, features, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);            
+        }
+        
+//        Log.d(TAG, "getAccountsByTypeAndFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+    
+    /**
+     * USE_CREDENTIALS
+     */
+    
+    @Override
+    public String blockingGetAuthToken(Account account, String authTokenType, boolean notifyAuthFailure)
+            throws OperationCanceledException, IOException, AuthenticatorException {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);    
+        String output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output = null;
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output = super.blockingGetAuthToken(account, authTokenType, notifyAuthFailure);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "blockingGetAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " 
+//                + (output == null ? "[null]" : output));
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Bundle> getAuthToken(Account account, String authTokenType, boolean notifyAuthFailure,
+            AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthToken(account, authTokenType, notifyAuthFailure, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "getAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Bundle> getAuthToken(Account account, String authTokenType, Bundle options,
+            Activity activity, AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthToken(account, authTokenType, options, activity, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "getAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+
+    /**
+     * MANAGE_ACCOUNTS
+     */
+    
+    @Override
+    public AccountManagerFuture<Bundle> getAuthTokenByFeatures(String accountType, String authTokenType,
+            String[] features, Activity activity, Bundle addAccountOptions, Bundle getAuthTokenOptions,
+            AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthTokenByFeatures(accountType, authTokenType, features, activity, addAccountOptions,
+                    getAuthTokenOptions, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "getAuthTokenByFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+    
+    /**
+     * Helper class. Used for returning custom values to AccountManager callers.
+     */
+    private class PrivacyAccountManagerFuture<V> implements AccountManagerFuture<V> {
+        
+        private V result;
+        
+        public PrivacyAccountManagerFuture(V result) {
+            this.result = result;
+        }
+
+        @Override
+        public boolean cancel(boolean mayInterruptIfRunning) {
+            return false;
+        }
+
+        @Override
+        public V getResult() throws OperationCanceledException, IOException, AuthenticatorException {
+            return result;
+        }
+
+        @Override
+        public V getResult(long timeout, TimeUnit unit) throws OperationCanceledException, IOException,
+                AuthenticatorException {
+            return result;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+
+        @Override
+        public boolean isDone() {
+            return true;
+        }
+        
+    }
+}
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java b/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java
--- a/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java	2012-08-10 03:30:54.992904617 +0000
@@ -0,0 +1,272 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.Intent;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.PrivacySettingsManagerService;
+import android.provider.Telephony;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link com.android.server.am.ActivityManagerService}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyActivityManagerService {
+    
+    private static final String TAG = "PrivacyActivityManagerService";
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    private static Intent tmpIn;
+    private static long tmpInHash = 0;
+    private static int tmpInReceivers = 0;
+    
+    private static Intent tmpOut;
+    private static long tmpOutHash = 0;
+    private static int tmpOutReceivers = 0;
+    
+    private static Intent tmpSms;
+    private static long tmpSmsHash = 0;
+    private static int tmpSmsReceivers = 0;
+    
+    private static Intent tmpMms;
+    private static long tmpMmsHash = 0;
+    private static int tmpMmsReceivers = 0;
+    
+    private static long tmpPackageAddedHash = 0;
+    
+    /**
+     * Intercepts broadcasts and replaces the broadcast contents according to 
+     * privacy permissions
+     * @param packageName may not be null
+     * @param uid must be >= 0
+     * @param intent intent.getAction() may not return null
+     */
+    public static void enforcePrivacyPermission(String packageName, int uid, Intent intent, Context context, int receivers) {
+        if (pSetMan == null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        PrivacySettings pSet;
+        String action = intent.getAction();
+        String output;
+        // outgoing call
+        if (action.equals(Intent.ACTION_NEW_OUTGOING_CALL)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+            
+            // store the original version to supply real values to trusted applications
+            // since Android sends the same intent to multiple receivers
+            if (tmpOutHash != hashCode(intent)) {
+                tmpOut = (Intent)intent.clone();
+                tmpOutHash = hashCode(intent);
+                tmpOutReceivers = receivers;
+            }
+            
+            try {
+                if (pSet != null && pSet.getOutgoingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    intent.putExtra(Intent.EXTRA_PHONE_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                } else if (tmpOutHash == hashCode(intent)) {
+                    // if this intent was stored before, get the real value since it could have been modified
+                    output = tmpOut.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+                    intent.putExtra(Intent.EXTRA_PHONE_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpOutReceivers > 1) {
+                tmpOutReceivers--;
+            } else { // free memory after all receivers have been served
+                tmpOut = null;
+            }
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming call
+        } else if (action.equals(TelephonyManager.ACTION_PHONE_STATE_CHANGED)
+                // the EXTRA_INCOMING_NUMBER is NOT only present when state is EXTRA_STATE_RINGING
+                // Android documentation is WRONG; the EXTRA_INCOMING_NUMBER will also be there when hanging up (IDLE?)
+                /* && intent.getStringExtra(TelephonyManager.EXTRA_STATE).equals(TelephonyManager.EXTRA_STATE_RINGING)*/) {
+            output = intent.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
+            // don't do anything if no incoming phone number is broadcasted
+            if (output == null || output.isEmpty()) return;
+            
+            pSet = pSetMan.getSettings(packageName, uid);
+            
+            if (tmpInHash != hashCode(intent)) {
+                tmpIn = (Intent)intent.clone();
+                tmpInHash = hashCode(intent);
+                tmpInReceivers = receivers;
+            }
+            
+            try {
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    intent.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                } else if (tmpInHash == hashCode(intent)) {
+                    output = tmpIn.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
+                    intent.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpInReceivers > 1) {
+                tmpInReceivers--;
+            } else { // free memory after all receivers have been served
+                tmpIn = null;
+            }
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming SMS
+        } else if (action.equals(Telephony.Sms.Intents.SMS_RECEIVED_ACTION)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = "[real]";
+//            Log.d(TAG, "package: " + packageName + " uid: " + uid);
+            
+            Object[] o = ((Object[])intent.getSerializableExtra("pdus"));
+            byte[] b = o != null ? (byte[])o[0] : null;
+            
+            if (tmpSmsHash != hashCode(intent)) {
+                tmpSms = (Intent)intent.clone();
+                tmpSmsHash = hashCode(intent);
+                tmpSmsReceivers = receivers;
+//                Log.d(TAG, "new intent; saving copy: receivers: " + receivers + " hash: " + tmpSmsHash + " " + 
+//                        "pdu number: " + (o != null ? o.length : "null") + " " + 
+//                        "1st pdu length: " + (b != null ? b.length : "null"));
+            } else {
+//                Log.d(TAG, "known intent; hash: " + hashCode(intent) + " remaining receivers: " + tmpSmsReceivers);
+            }
+            
+            try {
+                if (pSet != null && pSet.getSmsSetting() != PrivacySettings.REAL) {
+                    output = "[empty]";
+                    
+                    Object[] emptypdusObj = new Object[1];
+                    emptypdusObj[0] = (Object) new byte[] {0,32,1,-127,-16,0,0,17,-112,1,48,34,34,-128,1,32};
+                    intent.putExtra("pdus", emptypdusObj);
+                    
+//                    Log.d(TAG, "permission denied, replaced pdu; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                        "1st pdu length:" + (b != null ? b.length : "null"));
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_SMS, null, pSet);
+                } else if (tmpSmsHash == hashCode(intent)) {
+                    intent.putExtra("pdus", tmpSms.getSerializableExtra("pdus"));
+                    
+                    o = ((Object[])intent.getSerializableExtra("pdus"));
+                    b = o != null ? (byte[])o[0] : null;
+//                    Log.d(TAG, "permission granted, inserting saved pdus; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                            "1st pdu length:" + (b != null ? b.length : "null"));
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SMS, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpSmsReceivers > 1) {
+                tmpSmsReceivers--;
+            } else { // free memory after all receivers have been served
+//                Log.d(TAG, "removing intent with hash: " + tmpSmsHash);
+                tmpSms = null;
+            }            
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming MMS
+        } else if (action.equals(Telephony.Sms.Intents.WAP_PUSH_RECEIVED_ACTION) ||
+                action.equals(Telephony.Sms.Intents.DATA_SMS_RECEIVED_ACTION)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = "[real]";
+            
+            Object[] o = ((Object[])intent.getSerializableExtra("pdus"));
+            byte[] b = o != null ? (byte[])o[0] : null;
+            
+            // TODO: remove unnecessary receivers count
+            if (tmpMmsHash != hashCode(intent)) {
+                tmpMms = (Intent)intent.clone();
+                tmpMmsHash = hashCode(intent);
+                tmpMmsReceivers = receivers;
+//                Log.d(TAG, "new intent; saving copy: receivers: " + receivers + " hash: " + tmpMmsHash + " " + 
+//                        "pdu number: " + (o != null ? o.length : "null") + " " + 
+//                        "1st pdu length: " + (b != null ? b.length : "null"));
+            } else {
+//                Log.d(TAG, "known intent; hash: " + hashCode(intent) + " remaining receivers: " + tmpMmsReceivers);
+            }
+            
+            try {
+                if (pSet != null && pSet.getMmsSetting() != PrivacySettings.REAL) {
+                    output = "[empty]";
+                    
+                    Object[] emptypdusObj = new Object[1];
+                    emptypdusObj[0] = (Object) new byte[] {0,32,1,-127,-16,0,0,17,-112,1,48,34,34,-128,1,32};
+                    intent.putExtra("pdus", emptypdusObj);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS, null, pSet);
+                } else if (tmpMmsHash == hashCode(intent)) {
+                    intent.putExtra("pdus", tmpMms.getSerializableExtra("pdus"));
+                    
+                    o = ((Object[])intent.getSerializableExtra("pdus"));
+                    b = o != null ? (byte[])o[0] : null;
+//                    Log.d(TAG, "permission granted, inserting saved pdus; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                            "1st pdu length:" + (b != null ? b.length : "null"));
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpMmsReceivers > 1) {
+                tmpMmsReceivers--;
+            } else { // free memory after all receivers have been served
+//                Log.d(TAG, "removing intent with hash: " + tmpMmsHash);
+                tmpMms = null;
+            }
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
+            pSetMan.setBootCompleted();
+            
+//            if (pSet != null && pSet.getIntentBootCompletedSetting() != PrivacySettings.REAL) {
+                // no notification since all applications will receive this -> spam
+//                intent.setAction("empty");
+//                pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INTENT_BOOT_COMPLETED, null, pSet);
+//            } else {
+//                intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+//                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INTENT_BOOT_COMPLETED, null, pSet);
+//            }
+        } else if (action.equals(Intent.ACTION_PACKAGE_ADDED)) {
+//            Log.d(TAG, "enforcePrivacyPermission - ACTION_PACKAGE_ADDED; receivers: " + receivers);
+            
+            // update privacy settings; only do this once for a single Intent
+            if (tmpPackageAddedHash != hashCode(intent)) {
+                tmpPackageAddedHash = hashCode(intent);
+                
+                String addedPackageName = intent.getData().getSchemeSpecificPart();
+                int addedUid = intent.getExtras().getInt(Intent.EXTRA_UID);
+//                Log.d(TAG, "enforcePrivacyPermission - installed package " + addedPackageName + " " + addedUid);
+                pSet = pSetMan.getSettings(addedPackageName, addedUid);
+                // the settings in the privacy DB contain a different UID
+                if (pSet != null && pSet.getUid() != addedUid) { // update the UID
+//                    Log.i(TAG, "installed package UID (" + addedUid + ") doesn't match privacy settings UID (" + pSet.getUid() + "); updating...");
+                    pSet.setUid(addedUid);
+                    /*boolean updateSuccess = */pSetMan.saveSettings(pSet);
+//                    if (!updateSuccess) Log.w(TAG, "could not update privacy settings UID; purge needed");
+                }
+            }
+        }
+    }
+    
+    private static long hashCode(Intent intent) {
+        long privacyHash = intent.getLongExtra("privacy_hash", 0);
+        if (privacyHash == 0) {
+            privacyHash = intent.filterHashCode() + System.currentTimeMillis();
+            intent.putExtra("privacy_hash", privacyHash);
+        }
+        return privacyHash;
+    }
+}
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java b/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java
--- a/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java	2012-08-10 03:30:54.992904617 +0000
@@ -0,0 +1,171 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.IContentProvider;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.provider.Browser;
+import android.provider.CalendarContract;
+import android.provider.CallLog;
+import android.provider.ContactsContract;
+import android.provider.Telephony.Mms;
+import android.provider.Telephony.MmsSms;
+import android.provider.Telephony.Sms;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link android.content.ContentResolver}
+ * @author Svyatoslav Hresyk 
+ * {@hide}
+ */
+public final class PrivacyContentResolver {
+    
+    private static final String TAG = "PrivacyContentResolver";
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    /**
+     * Returns a dummy database cursor if access is restricted by privacy settings
+     * @param uri
+     * @param context
+     * @param realCursor
+     */
+    public static Cursor enforcePrivacyPermission(Uri uri, String[] projection, Context context, Cursor realCursor) throws RemoteException {
+//    public static Cursor enforcePrivacyPermission(Uri uri, Context context, Cursor realCursor) {
+        if (uri != null) {
+            if (pSetMan == null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            String auth = uri.getAuthority();
+            String output_label = "[real]";
+            Cursor output = realCursor;
+            if (auth != null) {
+                if (auth.equals(android.provider.Contacts.AUTHORITY) || auth.equals(ContactsContract.AUTHORITY)) {
+
+                    if (pSet != null) {
+                        if (pSet.getContactsSetting() == PrivacySettings.EMPTY) {
+                            output_label = "[empty]";
+                            output = new PrivacyCursor();
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        } else if (pSet.getContactsSetting() == PrivacySettings.CUSTOM && 
+                                uri.toString().contains(ContactsContract.Contacts.CONTENT_URI.toString())) {
+//                            Log.d(TAG, "enforcePrivacyPermission - URI: " + uri.toString() + " " + uri.getAuthority() + " " + uri.getEncodedAuthority() + " " + uri.getEncodedFragment() + " " + uri.getEncodedPath() + " " + uri.getEncodedQuery() + " " + uri.getEncodedSchemeSpecificPart() + " " + uri.getEncodedUserInfo() + " " + uri.getFragment() + " " + uri.getPath());
+//                            Log.d(TAG, "enforcePrivacyPermission - projection: " + arrayToString(projection) + " selection: " + selection + " selectionArgs: " + arrayToString(selectionArgs));
+//                            Log.d(TAG, "enforcePrivacyPermission - cursor entries: " + output.getCount());
+                            
+                            boolean idFound = false;
+                            if (projection != null) {
+                                for (String p : projection) {
+                                    if (p.equals(ContactsContract.Contacts._ID)) {
+                                        idFound = true;
+                                        break;
+                                    }
+                                }
+                                
+//                                if (!idFound) { // add ID to projection
+//                                    String[] newProjection = new String[projection.length + 1];
+//                                    System.arraycopy(projection, 0, newProjection, 0, projection.length);
+//                                    newProjection[projection.length] = ContactsContract.Contacts._ID;
+//                                    projection = newProjection;
+//                                }
+                            }
+                            
+                            if (!idFound) {
+                                output = new PrivacyCursor();
+                            } else {
+//                            Log.d(TAG, "enforcePrivacyPermission - new projection: " + arrayToString(projection) + " selection: " + selection + " selectionArgs: " + arrayToString(selectionArgs));
+                            
+                            // re-query
+//                            output = provider.query(uri, projection, selection, selectionArgs, sortOrder);
+//                            Log.d(TAG, "enforcePrivacyPermission - new cursor entries: " + output.getCount());
+                                output = new PrivacyCursor(output, pSet.getAllowedContacts());
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        } else { // REAL
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        }
+                    }
+                    
+                } else if (auth.equals(CalendarContract.AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getCalendarSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    }
+                    
+                } else if (auth.equals(Mms.CONTENT_URI.getAuthority())) {
+                    
+                    if (pSet != null && pSet.getMmsSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS, null, pSet);
+                    }
+                    
+                } else if (auth.equals(Sms.CONTENT_URI.getAuthority())) {
+                    
+                    if (pSet != null && pSet.getSmsSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_SMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SMS, null, pSet);
+                    }
+                // all messages, sms and mms
+                } else if (auth.equals(MmsSms.CONTENT_URI.getAuthority()) || 
+                        auth.equals("mms-sms-v2") /* htc specific, accessed by system messages application */) { 
+                    
+                    // deny access if access to either sms, mms or both is restricted by privacy settings
+                    if (pSet != null && (pSet.getMmsSetting() == PrivacySettings.EMPTY || 
+                            pSet.getSmsSetting() == PrivacySettings.EMPTY)) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    }
+
+                } else if (auth.equals(CallLog.AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getCallLogSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    }
+
+                } else if (auth.equals(Browser.BOOKMARKS_URI.getAuthority())) {
+                    
+                    if (pSet != null && pSet.getBookmarksSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    }
+                    
+                }
+            }
+//            Log.d(TAG, "query - " + packageName + " (" + uid + ") auth: " + auth + " output: " + output_label);
+            return output;
+        }
+        return realCursor;
+    }
+    
+    private static String arrayToString(String[] array) {
+        StringBuffer sb = new StringBuffer();
+        if (array != null) for (String bla : array) sb.append("[" + bla + "]");
+        else return "";
+        return sb.toString();
+    }
+}
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyCursor.java b/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyCursor.java
--- a/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyCursor.java	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyCursor.java	2012-08-10 03:30:54.992904617 +0000
@@ -0,0 +1,404 @@
+package android.privacy.surrogate;
+
+import android.content.ContentResolver;
+import android.database.CharArrayBuffer;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.database.DataSetObserver;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.ContactsContract;
+import android.util.Log;
+
+import java.util.Map;
+
+/**
+ * Dummy database cursor. Used by {@link android.privacy.surrogate.PrivacyContentResolver} 
+ * when access should be blocked without crashing the calling application (for this purpose none 
+ * of the methods returns null) or for fine-granular control of access to individual database entries.
+ * The latter may produce inconsistencies from the applicatin point of view based on getPosition()
+ * and moveToPosition().
+ * {@hide}
+ */
+public class PrivacyCursor implements Cursor {
+    
+    private Cursor realCursor;
+    
+    private int[] allowedIds;
+    
+    private int[] allowedIdMapping;
+    
+    private final static String TAG = "PrivacyCursor";
+    
+    public PrivacyCursor() {
+    }
+    
+    /**
+     * 
+     * @param realCursor may not be null
+     * @param allowedIds
+     */
+    public PrivacyCursor(Cursor realCursor, int[] allowedIds) {
+        this.realCursor = (allowedIds == null || allowedIds.length == 0) ? null : realCursor;
+        this.allowedIds = allowedIds;
+        if (this.realCursor != null) {
+            int currentPos = this.realCursor.getPosition();
+            this.allowedIdMapping = new int[allowedIds.length];
+            int i = 0;
+            while (this.realCursor.moveToNext()) {
+                if (isAllowed(this.realCursor)) {
+                    allowedIdMapping[i] = this.realCursor.getPosition();
+                    i++;
+                }
+            }
+            this.realCursor.moveToPosition(currentPos);
+        }
+    }
+
+    @Override
+    public void close() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.close();
+    }
+
+    @Override
+    public void copyStringToBuffer(int columnIndex, CharArrayBuffer buffer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.copyStringToBuffer(columnIndex, buffer);
+    }
+
+    @Override
+    public void deactivate() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.deactivate();
+    }
+
+    @Override
+    public byte[] getBlob(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getBlob(columnIndex);
+        return new byte[0];
+    }
+
+    @Override
+    public int getColumnCount() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnCount();
+        return 0;
+    }
+
+    @Override
+    public int getColumnIndex(String columnName) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnIndex(columnName);
+        return -1;
+    }
+
+    @Override
+    public int getColumnIndexOrThrow(String columnName) throws IllegalArgumentException {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnIndexOrThrow(columnName);
+        return -1;
+    }
+
+    @Override
+    public String getColumnName(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnName(columnIndex);
+        return "";
+    }
+
+    @Override
+    public String[] getColumnNames() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnNames();
+        return new String[] { "" };
+    }
+
+    @Override
+    public int getCount() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) {
+            Log.d(TAG, "getCount: " + allowedIdMapping.length);
+            return allowedIdMapping.length;
+        }
+        return 0;
+    }
+
+    @Override
+    public double getDouble(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getDouble(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public Bundle getExtras() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getExtras();
+        return new Bundle();
+    }
+
+    @Override
+    public float getFloat(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getFloat(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public int getInt(int columnIndex) {
+        if (realCursor != null) {
+            int result = realCursor.getInt(columnIndex);
+//            Log.d(TAG, "getInt - columnIndex: " + columnIndex + " name: " + realCursor.getColumnName(columnIndex) + " result: " + result);
+            return result;
+        }
+        return 0;
+    }
+
+    @Override
+    public long getLong(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getLong(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public int getPosition() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) {
+            int result = getMappedPos(realCursor.getPosition());
+            Log.d(TAG, "getPosition - mapped position: " + result + " real position: " + realCursor.getPosition());
+            return result;
+        }
+        return -1;
+    }
+
+    @Override
+    public short getShort(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getShort(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public String getString(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getString(columnIndex);
+        return "";
+    }
+
+    @Override
+    public int getType(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getType(columnIndex);
+        return realCursor.FIELD_TYPE_NULL;
+    }
+
+    @Override
+    public boolean getWantsAllOnMoveCalls() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getWantsAllOnMoveCalls();
+        return false;
+    }
+
+    @Override
+    public boolean isAfterLast() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isAfterLast();
+        return false;
+    }
+
+    @Override
+    public boolean isBeforeFirst() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isBeforeFirst();
+        return false;
+    }
+
+    @Override
+    public boolean isClosed() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isClosed();
+        return false;
+    }
+
+    @Override
+    public boolean isFirst() {
+        if (realCursor != null) {
+//            Log.d(TAG, "isFirst");
+            if (realCursor.getPosition() == allowedIdMapping[0]) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isLast() {
+        if (realCursor != null) {
+//            Log.d(TAG, "isLast");
+            if (realCursor.getPosition() == allowedIdMapping[allowedIdMapping.length - 1]) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isNull(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isNull(columnIndex);
+        return false;
+    }
+
+    @Override
+    public boolean move(int offset) {
+        if (realCursor != null) {
+            Log.d(TAG, "move - offset: " + offset);
+            try {
+                int realPos = allowedIdMapping[getMappedPos(realCursor.getPosition()) + offset];
+                boolean result = realCursor.moveToPosition(realPos);
+//                Log.d(TAG, "move - position: " + realCursor.getPosition() + " result: " + result);
+                return result;
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToFirst() {
+        if (realCursor != null) {
+            boolean result = realCursor.moveToPosition(allowedIdMapping[0]); 
+//            Log.d(TAG, "moveToFirst - position: " + allowedIdMapping[0] + " result: " + result);
+            return result;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToLast() {
+        if (realCursor != null) {
+            boolean result = realCursor.moveToPosition(allowedIdMapping[allowedIdMapping.length - 1]);
+//            Log.d(TAG, "moveToLast - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToNext() {
+        if (realCursor != null) {
+            if (!realCursor.moveToNext()) return false;
+            boolean result = true;
+            while (result == true && !isAllowed(realCursor)) result = realCursor.moveToNext();
+//            Log.d(TAG, "moveToNext - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToPosition(int position) {
+        if (realCursor != null) {
+            try {
+                boolean result = realCursor.moveToPosition(allowedIdMapping[position]);
+//                Log.d(TAG, "moveToPosition - real position: " + realCursor.getPosition() + " result: " + result);
+                return result;
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToPrevious() {
+        if (realCursor != null) {
+            if (!realCursor.moveToPrevious()) return false;
+            boolean result = true;
+            while (result == true && !isAllowed(realCursor)) result = realCursor.moveToPrevious();
+//            Log.d(TAG, "moveToPrevious - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }        
+        return false;
+    }
+
+    @Override
+    public void registerContentObserver(ContentObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.registerContentObserver(observer);        
+    }
+
+    @Override
+    public void registerDataSetObserver(DataSetObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.registerDataSetObserver(observer);        
+    }
+
+    @Override
+    public boolean requery() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.requery();
+        return false;
+    }
+
+    @Override
+    public Bundle respond(Bundle extras) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.respond(extras);        
+        return new Bundle();
+    }
+
+    @Override
+    public void setNotificationUri(ContentResolver cr, Uri uri) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.setNotificationUri(cr, uri);        
+    }
+
+    @Override
+    public void unregisterContentObserver(ContentObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.unregisterContentObserver(observer);        
+    }
+
+    @Override
+    public void unregisterDataSetObserver(DataSetObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.unregisterDataSetObserver(observer);
+    }
+
+    private int getContactId(Cursor c) {
+        int colIndex = c.getColumnIndex(ContactsContract.Contacts._ID);
+        int result = -1;
+        if (colIndex != -1) result = c.getInt(colIndex); 
+//        Log.d(TAG, "getContactId - colIndex: " + colIndex + " id: " + result);
+        return result;
+    }
+    
+    private boolean isAllowed(int id) {
+        boolean result = false;
+        for (int i : allowedIds) {
+            if (id == i) {
+                result = true;
+                break;
+            }
+        }
+//        Log.d(TAG, "isAllowed - id: " + id + " result: " + result);
+        return result;
+    }
+    
+    private boolean isAllowed(Cursor realCursor) {
+        return isAllowed(getContactId(realCursor));
+    }
+    
+    /**
+     * TODO: switch to HashMap etc to speed this up?
+     * @param realPos
+     * @return
+     */
+    private int getMappedPos(int realPos) {
+        for (int i = 0; i < allowedIdMapping.length; i++) {
+            if (allowedIdMapping[i] == realPos) return i;
+        }
+        return -1;
+    }
+}
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java b/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java
--- a/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java	2012-08-10 03:30:54.992904617 +0000
@@ -0,0 +1,520 @@
+package android.privacy.surrogate;
+
+import android.app.PendingIntent;
+import android.content.Context;
+import android.location.Criteria;
+import android.location.ILocationManager;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.location.LocationProvider;
+import android.location.GpsStatus.NmeaListener;
+import android.os.Binder;
+import android.os.Looper;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link android.location.LocationManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyLocationManager extends LocationManager {
+
+    private static final String TAG = "PrivacyLocationManager";
+    
+    private static final int CUSTOM_LOCATION_UPDATE_COUNT = 5;
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private Object lock = new Object();
+    
+    /** {@hide} */
+    public PrivacyLocationManager(ILocationManager service, Context context) {
+        super(service);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));        
+    }
+
+    @Override
+    public boolean addNmeaListener(NmeaListener listener) {
+        // only blocks if access is not allowed
+        // custom and random values not implemented due to Decimal Degrees->NMEA conversion complexity
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        
+        if (pSet != null && pSet.getLocationGpsSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+            return false;
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+        }
+//        Log.d(TAG, "addNmeaListener - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: [real value]");
+        return super.addNmeaListener(listener);
+    }
+
+    @Override
+    public Location getLastKnownLocation(String provider) {
+        if (provider == null) return super.getLastKnownLocation(provider);
+        
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        Location output = null;
+        
+        if (pSet != null) {
+            if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.getLastKnownLocation(provider);
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                                (output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null), pSet);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                        break;
+                    case PrivacySettings.CUSTOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationGpsLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationGpsLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                    case PrivacySettings.RANDOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationGpsLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationGpsLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                }
+            } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.getLastKnownLocation(provider);
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                        break;
+                    case PrivacySettings.CUSTOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationNetworkLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationNetworkLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                    case PrivacySettings.RANDOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationNetworkLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationNetworkLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                }
+            } else if (provider.equals(LocationManager.PASSIVE_PROVIDER) && 
+                    pSet.getLocationGpsSetting() == PrivacySettings.REAL && 
+                            pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                // only output real location if both gps and network are allowed
+                output = super.getLastKnownLocation(provider);
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            }
+        } else {
+            output = super.getLastKnownLocation(provider);
+            if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, 
+                    output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            } else { // including GPS and passive providers
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            }
+        }
+        
+//        Log.d(TAG, "getLastKnownLocation - " + context.getPackageName() + " (" + Binder.getCallingUid() + 
+//                ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public LocationProvider getProvider(String name) {
+        if (name == null) return super.getProvider(name);
+        
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        LocationProvider output = null;
+        
+        if (pSet != null) {
+            if (name.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = super.getProvider(name);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                }
+            } else if (name.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = super.getProvider(name);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                }
+            } else if (name.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                if (pSet.getLocationGpsSetting() == PrivacySettings.REAL || 
+                        pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                    output = super.getProvider(name);
+                }
+            }
+        } else {
+            output = super.getProvider(name);
+        }
+            
+//        Log.d(TAG, "getProvider - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + 
+//                (output != null ? "[real value]" : "[null]"));
+        return output;
+    }
+
+    @Override
+    public boolean isProviderEnabled(String provider) {
+        if (provider == null) return super.isProviderEnabled(provider);
+        
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        boolean output = false;
+        
+        if (pSet != null) {
+            if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.isProviderEnabled(provider);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = true;
+                        break;
+                }
+            } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.isProviderEnabled(provider);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = true;
+                        break;
+                }
+            } else if (provider.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                if (pSet.getLocationGpsSetting() == PrivacySettings.REAL || 
+                        pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                    output = super.isProviderEnabled(provider);
+                } else {
+                    output = false;
+                }
+            }
+        } else { // if querying unknown provider
+            output = super.isProviderEnabled(provider);
+        }
+        
+//        Log.d(TAG, "isProviderEnabled - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") provider: " 
+//                + provider + "output: " + output);
+        return output;
+    }
+
+    @Override
+    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, LocationListener listener,
+            Looper looper) {
+        if (criteria == null || listener == null) {
+            super.requestLocationUpdates(minTime, minDistance, criteria, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(criteria, listener, null)) return;
+        super.requestLocationUpdates(minTime, minDistance, criteria, listener, looper);
+    }
+
+    @Override
+    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, PendingIntent intent) {
+        if (criteria == null || intent == null) {
+            super.requestLocationUpdates(minTime, minDistance, criteria, intent);
+            return;
+        }
+        if (requestLocationUpdates(criteria, null, intent)) return;
+        super.requestLocationUpdates(minTime, minDistance, criteria, intent);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener,
+            Looper looper) {
+        if (provider == null || listener == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, listener, looper);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener) {
+        if (provider == null || listener == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, listener);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, listener);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, PendingIntent intent) {
+        if (provider == null || intent == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, intent);
+            return;
+        }
+        if (requestLocationUpdates(provider, null, intent)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, intent);
+    }
+
+    @Override
+    public void requestSingleUpdate(Criteria criteria, LocationListener listener, Looper looper) {
+        if (criteria == null || listener == null) {
+            super.requestSingleUpdate(criteria, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(criteria, listener, null)) return;
+        super.requestSingleUpdate(criteria, listener, looper);
+    }
+
+    @Override
+    public void requestSingleUpdate(Criteria criteria, PendingIntent intent) {
+        if (criteria == null || intent == null) {
+            super.requestSingleUpdate(criteria, intent);
+            return;
+        }
+        if (requestLocationUpdates(criteria, null, intent)) return;
+        super.requestSingleUpdate(criteria, intent);
+    }
+
+    @Override
+    public void requestSingleUpdate(String provider, LocationListener listener, Looper looper) {
+        if (provider == null || listener == null) {
+            super.requestSingleUpdate(provider, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestSingleUpdate(provider, listener, looper);
+    }
+
+    @Override
+    public void requestSingleUpdate(String provider, PendingIntent intent) {
+        if (provider == null || intent == null) {
+            super.requestSingleUpdate(provider, intent);
+            return;
+        }
+        if (requestLocationUpdates(provider, null, intent)) return;
+        super.requestSingleUpdate(provider, intent);
+    }
+    
+    /**
+     * Monitoring purposes only
+     */
+//    @Override
+//    public boolean sendExtraCommand(String provider, String command, Bundle extras) {
+//        Log.d(TAG, "sendExtraCommand - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+//        return super.sendExtraCommand(provider, command, extras);
+//    }
+
+    /**
+     * Handles calls to requestLocationUpdates and requestSingleUpdate methods
+     * @return true, if action has been taken
+     *         false, if the processing needs to be passed to the default method
+     */
+    private boolean requestLocationUpdates(String provider, LocationListener listener, PendingIntent intent) {
+        synchronized (lock) { // custom listener should only return a value after this method has returned
+
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            boolean output = false;
+            
+            if (pSet != null) {
+                if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                    switch (pSet.getLocationGpsSetting()) {
+                        case PrivacySettings.REAL:
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);                            
+                            break;
+                        case PrivacySettings.EMPTY:
+                            if (intent != null) intent.cancel();
+                            output = true;
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);                            
+                            break;
+                        case PrivacySettings.CUSTOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationGpsLat()), 
+                                        Double.parseDouble(pSet.getLocationGpsLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            break;
+                        case PrivacySettings.RANDOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationGpsLat()), 
+                                        Double.parseDouble(pSet.getLocationGpsLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            break;
+                    }
+                } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                    switch (pSet.getLocationNetworkSetting()) {
+                        case PrivacySettings.REAL:
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);                            
+                            break;
+                        case PrivacySettings.EMPTY:
+                            if (intent != null) intent.cancel();
+                            output = true;
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);                            
+                            break;
+                        case PrivacySettings.CUSTOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationNetworkLat()), 
+                                        Double.parseDouble(pSet.getLocationNetworkLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            break;
+                        case PrivacySettings.RANDOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationNetworkLat()), 
+                                        Double.parseDouble(pSet.getLocationNetworkLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            break;
+                    }
+                } else if (provider.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                    if (pSet.getLocationGpsSetting() == PrivacySettings.REAL && 
+                            pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                        output = false;
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    } else {
+                        output = true;
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    }
+                }
+            } else {
+                if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                } else { // including GPS and passive providers
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                }
+            }
+            
+//            Log.d(TAG, "requestLocationUpdates - " + context.getPackageName() + " (" + Binder.getCallingUid() + 
+//                    ") output: " + (output == true ? "[custom location]" : "[real value]"));
+            return output;
+        }
+    }
+    
+    /**
+     * Helper method for categorizing the different requestLocationUpdates calls by
+     * provider accuracy and handing them off to 
+     * {@link android.privacy.surrogate.PrivacyLocationManager#requestLocationUpdates(String, LocationListener, PendingIntent)}
+     * @param criteria
+     * @param listener
+     * @param intent
+     * @return see {@link android.privacy.surrogate.PrivacyLocationManager#requestLocationUpdates(String, LocationListener, PendingIntent)}
+     */
+    private boolean requestLocationUpdates(Criteria criteria, LocationListener listener, PendingIntent intent) {
+        if (criteria == null) return false;
+            // treat providers with high accuracy as GPS providers
+        else if (criteria.getAccuracy() == Criteria.ACCURACY_FINE || 
+                criteria.getBearingAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getHorizontalAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getVerticalAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getSpeedAccuracy() == Criteria.ACCURACY_HIGH) {
+            return requestLocationUpdates(LocationManager.GPS_PROVIDER, listener, intent);
+        } else { // treat all others as network providers
+            return requestLocationUpdates(LocationManager.NETWORK_PROVIDER, listener, intent);
+        }
+    }
+    
+    private class PrivacyLocationUpdater extends Thread {
+        
+        private String provider;
+        
+        private LocationListener listener;
+        
+        private PendingIntent intent;
+        
+        private double latitude;
+        
+        private double longitude;
+
+        public PrivacyLocationUpdater(String provider, LocationListener listener, PendingIntent intent,
+                double latitude, double longitude) {
+            this.provider = provider;
+            this.listener = listener;
+            this.intent = intent;
+            this.latitude = latitude;
+            this.longitude = longitude;
+        }
+
+        @Override
+        public void run() {
+            if (provider != null) {
+                Location location = new Location(provider);
+                location.setLatitude(latitude);
+                location.setLongitude(longitude);
+                for (int i = 0; i < CUSTOM_LOCATION_UPDATE_COUNT; i++) {
+                    if (listener != null) {
+                        listener.onLocationChanged(location);
+                    } else if (intent != null) {
+                        // no custom or random location implemented due to complexity
+                        intent.cancel();
+                    }
+                    try {
+                        sleep((int)(Math.random() * 1000));
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+        }
+        
+    }
+
+}
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java b/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java
--- a/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java	1970-01-01 00:00:00.000000000 +0000
+++ b/frameworks/base/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java	2012-08-10 03:30:54.992904617 +0000
@@ -0,0 +1,285 @@
+package android.privacy.surrogate;
+
+import com.android.internal.telephony.IPhoneStateListener;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * Provides privacy handling for {@link android.telephony.TelephonyManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyTelephonyManager extends TelephonyManager {
+
+    private static final String TAG = "PrivacyTelephonyManager";
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    /** {@hide} */
+    public PrivacyTelephonyManager(Context context) {
+        super(context);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        // don't call getSystemService to avoid getting java.lang.IllegalStateException: 
+        // System services not available to Activities before onCreate()
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    }
+    
+    /**
+     * IMEI
+     */
+    @Override
+    public String getDeviceId() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+//        Log.d(TAG, "getDeviceId - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Phone number
+     */
+    @Override
+    public String getLine1Number() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getLine1Number();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+//        Log.d(TAG, "getLine1Number - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Will be handled like the Line1Number, since voice mailbox numbers often
+     * are similar to the phone number of the subscriber.
+     */
+    @Override
+    public String getVoiceMailNumber() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+//        Log.d(TAG, "getVoiceMailNumber - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Intercept requests for mobile network cell information. This can be used for tracking network
+     * based location.
+     */
+    @Override
+    public List<NeighboringCellInfo> getNeighboringCellInfo() {
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        List<NeighboringCellInfo> output = null;
+        String output_label = "[null]";
+        
+        if (pSet != null) {
+            if (pSet.getLocationNetworkSetting() == PrivacySettings.EMPTY) {
+                // output = null;
+            } else if (pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                output = new ArrayList<NeighboringCellInfo>();
+                output_label = "[empty list of cells]";
+            } else {
+                output = super.getNeighboringCellInfo();
+                String cells = "";
+                for (NeighboringCellInfo i : output) cells += "\t" + i + "\n";
+                output_label = "[real value]:\n" + cells;
+            }
+        }
+        
+//        Log.d(TAG, "getNeighboringCellInfo - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);
+        return output;
+    }
+    
+    @Override
+    public String getNetworkCountryIso() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkCountryIso();
+//        Log.d(TAG, "getNetworkCountryIso - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getNetworkOperator() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkOperator();
+//        Log.d(TAG, "getNetworkOperator - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getNetworkOperatorName() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkOperatorName();
+//        Log.d(TAG, "getNetworkOperatorName - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Handles following Network Information requests: CountryIso, Operator Code, Operator Name
+     * @return value to return if applicable or null if real value should be returned
+     */
+    private String getNetworkInfo() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        if (pSet != null && pSet.getNetworkInfoSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);            
+            return ""; // can only be empty
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);            
+            return null;
+        }        
+    }
+    
+    @Override
+    public String getSimCountryIso() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimCountryIso();
+//        Log.d(TAG, "getSimCountryIso - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getSimOperator() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimOperator();
+//        Log.d(TAG, "getSimOperator - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getSimOperatorName() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimOperatorName();
+//        Log.d(TAG, "getSimOperatorName - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Handles following SIM Card information requests: CountryIso, Operator Code, Operator Name
+     * @return value to return if applicable or null if real value should be returned
+     */    
+    private String getSimInfo() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        if (pSet != null && pSet.getSimInfoSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);            
+            return ""; // can only be empty
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);            
+            return null;
+        }                
+    }
+    
+    /**
+     * ICCID
+     */
+    @Override
+    public String getSimSerialNumber() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSimSerialNumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getSimSerialNumber(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSimSerialNumberSetting(), PrivacySettings.DATA_SIM_SERIAL, output, pSet);            
+        } else {
+            output = super.getSimSerialNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SIM_SERIAL, output, pSet);            
+        }
+//        Log.d(TAG, "getSimSerialNumber - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * IMSI
+     */
+    @Override
+    public String getSubscriberId() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+//        Log.d(TAG, "getSubscriberId - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    /**
+     * For monitoring purposes only
+     */    
+//    @Override
+//    public void enableLocationUpdates() {
+////        Log.d(TAG, "enableLocationUpdates - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+//        super.enableLocationUpdates();
+//    }
+
+    @Override
+    public void listen(PhoneStateListener listener, int events) {
+//        Log.d(TAG, "listen - package:" + context.getPackageName() + " uid:" + Binder.getCallingUid() + " events: " + events);
+        if (((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) ||
+                ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0)) {
+            listener.setContext(context);
+            listener.setPackageName(context.getPackageName());
+            listener.setUid(Binder.getCallingUid());
+            super.listen(listener, events);
+//            Log.d(TAG, "listen for cell location or call state - " + context.getPackageName() + " (" + 
+//                    Binder.getCallingUid() + ") output: custom listener");
+        } else {
+            super.listen(listener, events);
+        }
+    }
+    
+}
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java b/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
--- a/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java	2012-08-10 03:24:58.988912681 +0000
+++ b/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java	2012-08-10 03:30:55.004906088 +0000
@@ -156,6 +156,9 @@ import java.util.Map.Entry;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
+// BEGIN privacy-added
+import android.privacy.surrogate.PrivacyActivityManagerService;
+// END privacy-added
 
 public final class ActivityManagerService extends ActivityManagerNative
         implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {
@@ -13414,6 +13417,32 @@ public final class ActivityManagerServic
             Binder.restoreCallingIdentity(origId);
         }
     }
+    // BEGIN privacy-added
+    private void enforcePrivacyPermission(Object nextReceiver, BroadcastRecord r) {
+        if (r != null && r.intent != null && r.intent.getAction() != null) {
+            
+            String packageName = null;
+            int uid = -1;
+            try { // try to get intent receiver information
+                if (nextReceiver instanceof BroadcastFilter) {
+                    packageName = ((BroadcastFilter) nextReceiver).receiverList.app.info.packageName;
+                    uid = ((BroadcastFilter) nextReceiver).receiverList.app.info.uid;
+                } else if (nextReceiver instanceof ResolveInfo) {
+                    packageName = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.packageName;
+                    uid = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.uid;
+                }
+            } catch (Exception e) {
+                // if above information is not available, exception will be thrown
+                // do nothing, this is not our intent
+                return;
+            }
+            
+            if (packageName != null && uid != -1) {
+                PrivacyActivityManagerService.enforcePrivacyPermission(packageName, uid, r.intent, mContext, r.receivers.size());
+            }
+        }
+    }
+    // END privacy-added
 
     // =========================================================
     // CONFIGURATION
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/services/java/com/android/server/am/BroadcastQueue.java b/frameworks/base/services/java/com/android/server/am/BroadcastQueue.java
--- a/frameworks/base/services/java/com/android/server/am/BroadcastQueue.java	2012-08-10 03:24:58.996912682 +0000
+++ b/frameworks/base/services/java/com/android/server/am/BroadcastQueue.java	2012-08-10 03:38:43.520911321 +0000
@@ -26,6 +26,7 @@ import android.content.IIntentReceiver;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
+import android.content.Context;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.IBinder;
@@ -36,6 +37,10 @@ import android.os.SystemClock;
 import android.os.UserId;
 import android.util.EventLog;
 import android.util.Slog;
+// BEGIN privacy-added
+import android.app.ActivityThread;
+import android.privacy.surrogate.PrivacyActivityManagerService;
+// END privacy-added
 
 /**
  * BROADCASTS
@@ -52,6 +57,7 @@ public class BroadcastQueue {
 
     static final int MAX_BROADCAST_HISTORY = 25;
 
+    Context mContext;
     final ActivityManagerService mService;
 
     /**
@@ -444,6 +450,40 @@ public class BroadcastQueue {
         }
     }
 
+
+    // BEGIN privacy-added
+    private void enforcePrivacyPermission(Object nextReceiver, BroadcastRecord r) {
+        if (r != null && r.intent != null && r.intent.getAction() != null) {
+            
+            String packageName = null;
+            int uid = -1;
+            try { // try to get intent receiver information
+                if (nextReceiver instanceof BroadcastFilter) {
+                    packageName = ((BroadcastFilter) nextReceiver).receiverList.app.info.packageName;
+                    uid = ((BroadcastFilter) nextReceiver).receiverList.app.info.uid;
+                } else if (nextReceiver instanceof ResolveInfo) {
+                    packageName = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.packageName;
+                    uid = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.uid;
+                }
+            } catch (Exception e) {
+                // if above information is not available, exception will be thrown
+                // do nothing, this is not our intent
+                return;
+            }
+            
+            if (packageName != null && uid != -1) {
+                try {
+                    ActivityThread at = ActivityThread.systemMain();
+                    mContext = at.getSystemContext();
+                    PrivacyActivityManagerService.enforcePrivacyPermission(packageName, uid, r.intent, mContext, r.receivers.size());
+                } catch (Exception e) {
+                    return;
+                }
+            }
+        }
+    }
+    // END privacy-added
+
     final void processNextBroadcast(boolean fromMsg) {
         synchronized(mService) {
             BroadcastRecord r;
@@ -623,6 +663,9 @@ public class BroadcastQueue {
             }
 
             Object nextReceiver = r.receivers.get(recIdx);
+            // BEGIN privacy-added
+            enforcePrivacyPermission(nextReceiver, r);
+            // END privacy-added
             if (nextReceiver instanceof BroadcastFilter) {
                 // Simple case: this is a registered receiver who gets
                 // a direct call.
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/services/java/com/android/server/SystemServer.java b/frameworks/base/services/java/com/android/server/SystemServer.java
--- a/frameworks/base/services/java/com/android/server/SystemServer.java	2012-08-10 03:24:59.060912682 +0000
+++ b/frameworks/base/services/java/com/android/server/SystemServer.java	2012-08-10 03:30:55.004906088 +0000
@@ -35,6 +35,9 @@ import android.os.ServiceManager;
 import android.os.StrictMode;
 import android.os.SystemClock;
 import android.os.SystemProperties;
+// BEGIN privacy-added
+import android.privacy.PrivacySettingsManagerService;
+// END privacy-added
 import android.provider.Settings;
 import android.server.BluetoothA2dpService;
 import android.server.BluetoothService;
@@ -199,6 +202,9 @@ class ServerThread extends Thread {
             Slog.i(TAG, "Content Manager");
             ContentService.main(context,
                     factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
+            // BEGIN privacy-added
+            addPrivacyService(context);
+            // END privacy-added
 
             Slog.i(TAG, "System Content Providers");
             ActivityManagerService.installSystemProviders();
@@ -883,6 +889,16 @@ class ServerThread extends Thread {
         Slog.d(TAG, "Starting service: " + intent);
         context.startService(intent);
     }
+    // BEGIN privacy-added
+    private void addPrivacyService(Context context) {
+        try {
+            Log.i(TAG, "Privacy Service");
+            ServiceManager.addService("privacy", new PrivacySettingsManagerService(context));
+        } catch (Throwable e) {
+            Log.e(TAG, "Failure starting Privacy Service", e);
+        }        
+    }
+    // END privacy-added
 }
 
 public class SystemServer {
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/telephony/java/android/telephony/PhoneStateListener.java b/frameworks/base/telephony/java/android/telephony/PhoneStateListener.java
--- a/frameworks/base/telephony/java/android/telephony/PhoneStateListener.java	2012-08-10 03:24:57.864912682 +0000
+++ b/frameworks/base/telephony/java/android/telephony/PhoneStateListener.java	2012-08-10 03:35:48.120913558 +0000
@@ -15,7 +15,13 @@
  */
 
 package android.telephony;
+// BEGIN privacy-added
+import com.android.internal.telephony.IPhoneStateListener;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+// END privacy-added
 
+import android.content.Context;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
@@ -165,6 +171,28 @@ public class PhoneStateListener {
      */
     public static final int LISTEN_CELL_INFO = 0x00000400;
 
+    // BEGIN privacy-added
+    private Context context;
+    private String packageName;
+    private int uid;
+    private final static String TAG = "PhoneStateListener"; 
+    
+    /** {@hide} */
+    public void setContext(Context context) {
+        this.context = context;
+    }
+    
+    /** {@hide} */
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+    
+    /** {@hide} */
+    public void setUid(int uid) {
+        this.uid = uid;
+    }    
+    // END privacy-added
+    
     public PhoneStateListener() {
     }
 
@@ -323,11 +351,49 @@ public class PhoneStateListener {
 
         public void onCellLocationChanged(Bundle bundle) {
             CellLocation location = CellLocation.newFromBundle(bundle);
-            Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+            // BEGIN privacy-modified
+            if (context != null) {
+                PrivacySettingsManager pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+                PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+//                String output;
+                if (pSet != null && pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                    // simply block the method call, since simulating cell location is not feasible
+//                    output = "[no output]";
+                    pSetMan.notification(packageName, uid, pSet.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);            
+                } else {
+//                    output = location.toString();
+                    Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);            
+                }
+//                Log.d(TAG, "onCellLocationChanged - " + context.getPackageName() + " (" + 
+//                        Binder.getCallingUid() + ") output: " + output);
+            }
+            // END privacy-modified
         }
 
         public void onCallStateChanged(int state, String incomingNumber) {
-            Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            // BEGIN privacy-modified
+//            Log.d(TAG, "onCallStateChanged - state:" + state + " incoming number:" + incomingNumber);
+            // only take action if an incoming phone number is actually transmitted
+            if (context != null && incomingNumber != null && !incomingNumber.isEmpty()) {
+                PrivacySettingsManager pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+                PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+                String output;
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, output).sendToTarget();
+//                    Log.d(TAG, "onCallStateChanged BLOCK - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, output, pSet);
+                } else {
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+//                    Log.d(TAG, "onCallStateChanged REAL 1 - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + incomingNumber);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, incomingNumber, pSet);
+                }
+            } else {
+//                Log.d(TAG, "onCallStateChanged REAL 2 - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + incomingNumber);
+                Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            }
+            // END privacy-modified
         }
 
         public void onDataConnectionStateChanged(int state, int networkType) {
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/frameworks/base/test-runner/Android.mk b/frameworks/base/test-runner/Android.mk
--- a/frameworks/base/test-runner/Android.mk	2012-08-10 03:25:00.216912681 +0000
+++ b/frameworks/base/test-runner/Android.mk	2012-08-10 04:15:32.820912682 +0000
@@ -20,7 +20,7 @@ include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES := $(call all-java-files-under, src)
 
-LOCAL_JAVA_LIBRARIES := core core-junit framework
+LOCAL_JAVA_LIBRARIES := core core-junit framework framework2
 
 LOCAL_MODULE:= android.test.runner
 
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/libcore/luni/src/main/java/java/lang/PrivacyInputStream.java b/libcore/luni/src/main/java/java/lang/PrivacyInputStream.java
--- a/libcore/luni/src/main/java/java/lang/PrivacyInputStream.java	1970-01-01 00:00:00.000000000 +0000
+++ b/libcore/luni/src/main/java/java/lang/PrivacyInputStream.java	2012-08-10 03:30:49.296914377 +0000
@@ -0,0 +1,36 @@
+package java.lang;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Simulates an empty InputStream
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public class PrivacyInputStream extends InputStream {
+
+    public PrivacyInputStream() {
+    }
+    
+    @Override
+    public int read() throws IOException {
+        return -1;
+    }
+    
+    @Override
+    public void close() throws IOException {
+        super.close();
+    }
+    
+    @Override
+    public int read(byte[] b, int offset, int length) throws IOException {
+        return -1;
+    }
+    
+    @Override
+    public int read(byte[] b) throws IOException {
+        return -1;
+    }
+    
+}   
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/libcore/luni/src/main/java/java/lang/PrivacyProcessManager.java b/libcore/luni/src/main/java/java/lang/PrivacyProcessManager.java
--- a/libcore/luni/src/main/java/java/lang/PrivacyProcessManager.java	1970-01-01 00:00:00.000000000 +0000
+++ b/libcore/luni/src/main/java/java/lang/PrivacyProcessManager.java	2012-08-10 03:30:49.296914377 +0000
@@ -0,0 +1,143 @@
+package java.lang;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStreamReader;
+
+/**
+ * Provides privacy handling for {@link java.lang.ProcessManager}
+ * @author Svyatoslav Hresyk
+ * TODO: test if this works, also test it with root apps
+ * {@hide}
+ */
+public class PrivacyProcessManager {
+    
+    private static final int GET_COMMAND_WAIT_MS = 10;
+    
+    private static final int GET_COMMAND_WAIT_STEP = 5;
+    
+    /**
+     * Verifies if the current process has privacy access permission
+     * to the specified setting
+     * @param setting name of the setting file (e.g., systemLogsSetting or 
+     *          externalStorageSetting)
+     * @return boolean true if permission is granted or false otherwise
+     */
+    public static boolean hasPrivacyPermission(String setting, int pid) {
+        String packageName = null;
+//        String uid = null;
+        boolean output = true;
+        try {
+            packageName = getPackageName();
+//            uid = getUid();
+        } catch (Exception e) {
+            System.err.println("PrivacyProcessManager: could not find package name or UID");
+            e.printStackTrace();
+        }
+        try {
+            PrivacyFileReader freader = null;
+            
+            // get the command line of starting process
+            String commandLineFile = "/proc/" + pid + "/cmdline";
+//            System.err.println("PrivacyProcessManager - hasPrivacyPermission: creating command line file FileReader for " + commandLineFile);
+            freader = new PrivacyFileReader(commandLineFile);
+            String proc = "";
+            for (int i = GET_COMMAND_WAIT_MS; (proc = freader.readLine()) == null && i >= 0; i=- GET_COMMAND_WAIT_STEP) {
+                try {
+                    Thread.sleep(GET_COMMAND_WAIT_STEP);
+                } catch (InterruptedException e) {
+                    // ignore
+                }
+//                System.err.println("PrivacyProcessManager - hasPrivacyPermission: read \"" + proc + "\" from " + commandLineFile);
+            }
+            freader.close();
+//            System.err.println("PrivacyProcessManager - hasPrivacyPermission: process: " + proc);
+            
+            // check if logs are being read
+            if (proc != null && proc.trim().length() > 5 && proc.contains("logcat")) {
+                // get setting value
+                String settingsFilePath = "/data/system/privacy/" + packageName + /*"/" + uid +*/ "/" + setting;
+//                System.err.println("PrivacyProcessManager - hasPrivacyPermission: creating settings file FileReader for " + settingsFilePath);
+                freader = new PrivacyFileReader(settingsFilePath);
+//                System.err.println("PrivacyProcessManager - hasPrivacyPermission: reading first line from " + settingsFilePath);
+                String line = freader.readLine();
+//                System.err.println("PrivacyProcessManager - hasPrivacyPermission: reading systemLogsSetting from the line");
+                int systemLogsSetting = line != null ? Integer.parseInt(line.trim()) : -1;
+                freader.close();
+                // check permission
+                if (systemLogsSetting == 1) output = false;
+            }
+        } catch (FileNotFoundException e) {
+            // no setting for this application; do nothing
+        } catch (Exception e) {
+            System.err.println("PrivacyProcessManager: could not read privacy settings: " + setting);
+            e.printStackTrace();
+        }
+//        System.err.println("PrivacyProcessManager - hasPrivacyPermission: returning: " + output);
+        
+        return output;
+    }
+    
+    /**
+     * Finds the package name corresponding to the current process
+     * @return Current process' package name
+     * @throws IOException, FileNotFoundException 
+     */
+    private static String getPackageName() throws IOException, FileNotFoundException {
+        PrivacyFileReader freader = new PrivacyFileReader("/proc/self/cmdline");
+        String packageName = freader.readLine().trim();
+        freader.close();
+        return packageName;
+    }
+    
+    /**
+     * Finds the UID corresponding to the current process
+     * @return Current process' UID
+     * @throws IOException, FileNotFoundException, NumberFormatException, Exception
+     */
+//    private static String getUid() throws IOException, FileNotFoundException, 
+//            NumberFormatException, Exception {
+//        PrivacyFileReader freader;
+//        try {
+//            freader = new PrivacyFileReader("/proc/self/cgroup");
+//        } catch (FileNotFoundException e) {
+//            // this is most likely root (UID 0)
+//            return "0";
+//        }
+//        String uid = null;
+//        String line = "";
+//        while (!line.contains("/uid/")) line = freader.readLine();
+//        freader.close();
+//        if (line != null) {
+//            int index = line.indexOf("/uid/");
+//            index += "/uid/".length();
+//            // make sure the found UID is an int and convert it back to string
+//            uid = Integer.parseInt(line.substring(index).trim()) + "";
+//        }
+//        if (uid != null) return uid;
+//        else throw new Exception();
+//    }
+    
+    public static class PrivacyFileReader {
+        
+        private FileInputStream inputStream;
+        
+        private BufferedReader buffReader;
+        
+        public PrivacyFileReader(String path) throws FileNotFoundException {
+            inputStream = new FileInputStream(new File(path));
+            buffReader = new BufferedReader(new InputStreamReader(inputStream));
+        }
+        
+        public String readLine() throws IOException {
+            return buffReader.readLine();
+        }
+        
+        public void close() throws IOException {
+            inputStream.close();            
+        }
+    }
+}
diff -Npur '--exclude=.svn' '--exclude=.git*' '--exclude=.repo' a/libcore/luni/src/main/java/java/lang/ProcessManager.java b/libcore/luni/src/main/java/java/lang/ProcessManager.java
--- a/libcore/luni/src/main/java/java/lang/ProcessManager.java	2012-08-10 03:25:21.756912681 +0000
+++ b/libcore/luni/src/main/java/java/lang/ProcessManager.java	2012-08-10 03:30:49.296914377 +0000
@@ -248,7 +248,12 @@ final class ProcessManager {
             this.pid = pid;
 
             this.errorStream = new ProcessInputStream(err);
-            this.inputStream = new ProcessInputStream(in);
+            // BEGIN privacy-modified
+            if (PrivacyProcessManager.hasPrivacyPermission("systemLogsSetting", pid))
+                this.inputStream = new ProcessInputStream(in);
+            else
+                this.inputStream = new PrivacyInputStream();
+            // END privacy-modified            
             this.outputStream = new ProcessOutputStream(out);
         }
 
